diff --git a/include/numpy/__multiarray_api.h b/include/numpy/__multiarray_api.h
index c949d732f..b9e197b9c 100644
--- a/include/numpy/__multiarray_api.h
+++ b/include/numpy/__multiarray_api.h
@@ -1,787 +1,623 @@
 
-#ifdef _MULTIARRAYMODULE
+#if defined(_MULTIARRAYMODULE) || defined(WITH_CPYCHECKER_STEALS_REFERENCE_TO_ARG_ATTRIBUTE)
 
 typedef struct {
         PyObject_HEAD
         npy_bool obval;
 } PyBoolScalarObject;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
 extern NPY_NO_EXPORT PyTypeObject PyArrayMapIter_Type;
 extern NPY_NO_EXPORT PyTypeObject PyArrayNeighborhoodIter_Type;
 extern NPY_NO_EXPORT PyBoolScalarObject _PyArrayScalar_BoolValues[2];
-#else
-NPY_NO_EXPORT PyTypeObject PyArrayMapIter_Type;
-NPY_NO_EXPORT PyTypeObject PyArrayNeighborhoodIter_Type;
-NPY_NO_EXPORT PyBoolScalarObject _PyArrayScalar_BoolValues[2];
-#endif
 
-NPY_NO_EXPORT unsigned int PyArray_GetNDArrayCVersion \
+NPY_NO_EXPORT  unsigned int PyArray_GetNDArrayCVersion \
        (void);
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyBigArray_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyBigArray_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyBigArray_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyArray_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyArray_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyArray_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyArrayDescr_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyArrayDescr_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyArrayDescr_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyArrayFlags_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyArrayFlags_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyArrayFlags_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyArrayIter_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyArrayIter_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyArrayIter_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyArrayMultiIter_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyArrayMultiIter_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyArrayMultiIter_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT int NPY_NUMUSERTYPES;
-#else
-    NPY_NO_EXPORT int NPY_NUMUSERTYPES;
-#endif
+extern NPY_NO_EXPORT int NPY_NUMUSERTYPES;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyBoolArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyBoolArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyBoolArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
 extern NPY_NO_EXPORT PyBoolScalarObject _PyArrayScalar_BoolValues[2];
-#else
-NPY_NO_EXPORT PyBoolScalarObject _PyArrayScalar_BoolValues[2];
-#endif
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyGenericArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyGenericArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyGenericArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyNumberArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyNumberArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyNumberArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyIntegerArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyIntegerArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyIntegerArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PySignedIntegerArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PySignedIntegerArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PySignedIntegerArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyUnsignedIntegerArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyUnsignedIntegerArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyUnsignedIntegerArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyInexactArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyInexactArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyInexactArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyFloatingArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyFloatingArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyFloatingArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyComplexFloatingArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyComplexFloatingArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyComplexFloatingArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyFlexibleArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyFlexibleArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyFlexibleArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyCharacterArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyCharacterArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyCharacterArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyByteArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyByteArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyByteArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyShortArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyShortArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyShortArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyIntArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyIntArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyIntArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyLongArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyLongArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyLongArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyLongLongArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyLongLongArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyLongLongArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyUByteArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyUByteArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyUByteArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyUShortArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyUShortArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyUShortArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyUIntArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyUIntArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyUIntArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyULongArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyULongArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyULongArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyULongLongArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyULongLongArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyULongLongArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyFloatArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyFloatArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyFloatArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyDoubleArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyDoubleArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyDoubleArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyLongDoubleArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyLongDoubleArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyLongDoubleArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyCFloatArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyCFloatArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyCFloatArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyCDoubleArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyCDoubleArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyCDoubleArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyCLongDoubleArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyCLongDoubleArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyCLongDoubleArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyObjectArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyObjectArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyObjectArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyStringArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyStringArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyStringArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyUnicodeArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyUnicodeArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyUnicodeArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyVoidArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyVoidArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyVoidArrType_Type;
 
-NPY_NO_EXPORT int PyArray_SetNumericOps \
+NPY_NO_EXPORT  int PyArray_SetNumericOps \
        (PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_GetNumericOps \
+NPY_NO_EXPORT  PyObject * PyArray_GetNumericOps \
        (void);
-NPY_NO_EXPORT int PyArray_INCREF \
+NPY_NO_EXPORT  int PyArray_INCREF \
        (PyArrayObject *);
-NPY_NO_EXPORT int PyArray_XDECREF \
+NPY_NO_EXPORT  int PyArray_XDECREF \
        (PyArrayObject *);
-NPY_NO_EXPORT void PyArray_SetStringFunction \
+NPY_NO_EXPORT  void PyArray_SetStringFunction \
        (PyObject *, int);
-NPY_NO_EXPORT PyArray_Descr * PyArray_DescrFromType \
+NPY_NO_EXPORT  PyArray_Descr * PyArray_DescrFromType \
        (int);
-NPY_NO_EXPORT PyObject * PyArray_TypeObjectFromType \
+NPY_NO_EXPORT  PyObject * PyArray_TypeObjectFromType \
        (int);
-NPY_NO_EXPORT char * PyArray_Zero \
+NPY_NO_EXPORT  char * PyArray_Zero \
        (PyArrayObject *);
-NPY_NO_EXPORT char * PyArray_One \
+NPY_NO_EXPORT  char * PyArray_One \
        (PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_CastToType \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(2) NPY_GCC_NONNULL(2) PyObject * PyArray_CastToType \
        (PyArrayObject *, PyArray_Descr *, int);
-NPY_NO_EXPORT int PyArray_CastTo \
+NPY_NO_EXPORT  int PyArray_CastTo \
        (PyArrayObject *, PyArrayObject *);
-NPY_NO_EXPORT int PyArray_CastAnyTo \
+NPY_NO_EXPORT  int PyArray_CastAnyTo \
        (PyArrayObject *, PyArrayObject *);
-NPY_NO_EXPORT int PyArray_CanCastSafely \
+NPY_NO_EXPORT  int PyArray_CanCastSafely \
        (int, int);
-NPY_NO_EXPORT npy_bool PyArray_CanCastTo \
+NPY_NO_EXPORT  npy_bool PyArray_CanCastTo \
        (PyArray_Descr *, PyArray_Descr *);
-NPY_NO_EXPORT int PyArray_ObjectType \
+NPY_NO_EXPORT  int PyArray_ObjectType \
        (PyObject *, int);
-NPY_NO_EXPORT PyArray_Descr * PyArray_DescrFromObject \
+NPY_NO_EXPORT  PyArray_Descr * PyArray_DescrFromObject \
        (PyObject *, PyArray_Descr *);
-NPY_NO_EXPORT PyArrayObject ** PyArray_ConvertToCommonType \
+NPY_NO_EXPORT  PyArrayObject ** PyArray_ConvertToCommonType \
        (PyObject *, int *);
-NPY_NO_EXPORT PyArray_Descr * PyArray_DescrFromScalar \
+NPY_NO_EXPORT  PyArray_Descr * PyArray_DescrFromScalar \
        (PyObject *);
-NPY_NO_EXPORT PyArray_Descr * PyArray_DescrFromTypeObject \
+NPY_NO_EXPORT  PyArray_Descr * PyArray_DescrFromTypeObject \
        (PyObject *);
-NPY_NO_EXPORT npy_intp PyArray_Size \
+NPY_NO_EXPORT  npy_intp PyArray_Size \
        (PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_Scalar \
+NPY_NO_EXPORT  PyObject * PyArray_Scalar \
        (void *, PyArray_Descr *, PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_FromScalar \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(2) PyObject * PyArray_FromScalar \
        (PyObject *, PyArray_Descr *);
-NPY_NO_EXPORT void PyArray_ScalarAsCtype \
+NPY_NO_EXPORT  void PyArray_ScalarAsCtype \
        (PyObject *, void *);
-NPY_NO_EXPORT int PyArray_CastScalarToCtype \
+NPY_NO_EXPORT  int PyArray_CastScalarToCtype \
        (PyObject *, void *, PyArray_Descr *);
-NPY_NO_EXPORT int PyArray_CastScalarDirect \
+NPY_NO_EXPORT  int PyArray_CastScalarDirect \
        (PyObject *, PyArray_Descr *, void *, int);
-NPY_NO_EXPORT PyObject * PyArray_ScalarFromObject \
+NPY_NO_EXPORT  PyObject * PyArray_ScalarFromObject \
        (PyObject *);
-NPY_NO_EXPORT PyArray_VectorUnaryFunc * PyArray_GetCastFunc \
+NPY_NO_EXPORT  PyArray_VectorUnaryFunc * PyArray_GetCastFunc \
        (PyArray_Descr *, int);
-NPY_NO_EXPORT PyObject * PyArray_FromDims \
-       (int, int *, int);
-NPY_NO_EXPORT PyObject * PyArray_FromDimsAndDataAndDescr \
-       (int, int *, PyArray_Descr *, char *);
-NPY_NO_EXPORT PyObject * PyArray_FromAny \
+NPY_NO_EXPORT  PyObject * PyArray_FromDims \
+       (int NPY_UNUSED(nd), int *NPY_UNUSED(d), int NPY_UNUSED(type));
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(3) PyObject * PyArray_FromDimsAndDataAndDescr \
+       (int NPY_UNUSED(nd), int *NPY_UNUSED(d), PyArray_Descr *, char *NPY_UNUSED(data));
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(2) PyObject * PyArray_FromAny \
        (PyObject *, PyArray_Descr *, int, int, int, PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_EnsureArray \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(1) PyObject * PyArray_EnsureArray \
        (PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_EnsureAnyArray \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(1) PyObject * PyArray_EnsureAnyArray \
        (PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_FromFile \
+NPY_NO_EXPORT  PyObject * PyArray_FromFile \
        (FILE *, PyArray_Descr *, npy_intp, char *);
-NPY_NO_EXPORT PyObject * PyArray_FromString \
+NPY_NO_EXPORT  PyObject * PyArray_FromString \
        (char *, npy_intp, PyArray_Descr *, npy_intp, char *);
-NPY_NO_EXPORT PyObject * PyArray_FromBuffer \
+NPY_NO_EXPORT  PyObject * PyArray_FromBuffer \
        (PyObject *, PyArray_Descr *, npy_intp, npy_intp);
-NPY_NO_EXPORT PyObject * PyArray_FromIter \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(2) PyObject * PyArray_FromIter \
        (PyObject *, PyArray_Descr *, npy_intp);
-NPY_NO_EXPORT PyObject * PyArray_Return \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(1) PyObject * PyArray_Return \
        (PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_GetField \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(2) NPY_GCC_NONNULL(2) PyObject * PyArray_GetField \
        (PyArrayObject *, PyArray_Descr *, int);
-NPY_NO_EXPORT int PyArray_SetField \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(2) NPY_GCC_NONNULL(2) int PyArray_SetField \
        (PyArrayObject *, PyArray_Descr *, int, PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_Byteswap \
+NPY_NO_EXPORT  PyObject * PyArray_Byteswap \
        (PyArrayObject *, npy_bool);
-NPY_NO_EXPORT PyObject * PyArray_Resize \
-       (PyArrayObject *, PyArray_Dims *, int, NPY_ORDER);
-NPY_NO_EXPORT int PyArray_MoveInto \
+NPY_NO_EXPORT  PyObject * PyArray_Resize \
+       (PyArrayObject *, PyArray_Dims *, int, NPY_ORDER NPY_UNUSED(order));
+NPY_NO_EXPORT  int PyArray_MoveInto \
        (PyArrayObject *, PyArrayObject *);
-NPY_NO_EXPORT int PyArray_CopyInto \
+NPY_NO_EXPORT  int PyArray_CopyInto \
        (PyArrayObject *, PyArrayObject *);
-NPY_NO_EXPORT int PyArray_CopyAnyInto \
+NPY_NO_EXPORT  int PyArray_CopyAnyInto \
        (PyArrayObject *, PyArrayObject *);
-NPY_NO_EXPORT int PyArray_CopyObject \
+NPY_NO_EXPORT  int PyArray_CopyObject \
        (PyArrayObject *, PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_NewCopy \
+NPY_NO_EXPORT NPY_GCC_NONNULL(1) PyObject * PyArray_NewCopy \
        (PyArrayObject *, NPY_ORDER);
-NPY_NO_EXPORT PyObject * PyArray_ToList \
+NPY_NO_EXPORT  PyObject * PyArray_ToList \
        (PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_ToString \
+NPY_NO_EXPORT  PyObject * PyArray_ToString \
        (PyArrayObject *, NPY_ORDER);
-NPY_NO_EXPORT int PyArray_ToFile \
+NPY_NO_EXPORT  int PyArray_ToFile \
        (PyArrayObject *, FILE *, char *, char *);
-NPY_NO_EXPORT int PyArray_Dump \
+NPY_NO_EXPORT  int PyArray_Dump \
        (PyObject *, PyObject *, int);
-NPY_NO_EXPORT PyObject * PyArray_Dumps \
+NPY_NO_EXPORT  PyObject * PyArray_Dumps \
        (PyObject *, int);
-NPY_NO_EXPORT int PyArray_ValidType \
+NPY_NO_EXPORT  int PyArray_ValidType \
        (int);
-NPY_NO_EXPORT void PyArray_UpdateFlags \
+NPY_NO_EXPORT  void PyArray_UpdateFlags \
        (PyArrayObject *, int);
-NPY_NO_EXPORT PyObject * PyArray_New \
-       (PyTypeObject *, int, npy_intp *, int, npy_intp *, void *, int, int, PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_NewFromDescr \
-       (PyTypeObject *, PyArray_Descr *, int, npy_intp *, npy_intp *, void *, int, PyObject *);
-NPY_NO_EXPORT PyArray_Descr * PyArray_DescrNew \
+NPY_NO_EXPORT NPY_GCC_NONNULL(1) PyObject * PyArray_New \
+       (PyTypeObject *, int, npy_intp const *, int, npy_intp const *, void *, int, int, PyObject *);
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(2) NPY_GCC_NONNULL(1) NPY_GCC_NONNULL(2) PyObject * PyArray_NewFromDescr \
+       (PyTypeObject *, PyArray_Descr *, int, npy_intp const *, npy_intp const *, void *, int, PyObject *);
+NPY_NO_EXPORT  PyArray_Descr * PyArray_DescrNew \
        (PyArray_Descr *);
-NPY_NO_EXPORT PyArray_Descr * PyArray_DescrNewFromType \
+NPY_NO_EXPORT  PyArray_Descr * PyArray_DescrNewFromType \
        (int);
-NPY_NO_EXPORT double PyArray_GetPriority \
+NPY_NO_EXPORT  double PyArray_GetPriority \
        (PyObject *, double);
-NPY_NO_EXPORT PyObject * PyArray_IterNew \
+NPY_NO_EXPORT  PyObject * PyArray_IterNew \
        (PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_MultiIterNew \
+NPY_NO_EXPORT  PyObject* PyArray_MultiIterNew \
        (int, ...);
-NPY_NO_EXPORT int PyArray_PyIntAsInt \
+NPY_NO_EXPORT  int PyArray_PyIntAsInt \
        (PyObject *);
-NPY_NO_EXPORT npy_intp PyArray_PyIntAsIntp \
+NPY_NO_EXPORT  npy_intp PyArray_PyIntAsIntp \
        (PyObject *);
-NPY_NO_EXPORT int PyArray_Broadcast \
+NPY_NO_EXPORT  int PyArray_Broadcast \
        (PyArrayMultiIterObject *);
-NPY_NO_EXPORT void PyArray_FillObjectArray \
+NPY_NO_EXPORT  void PyArray_FillObjectArray \
        (PyArrayObject *, PyObject *);
-NPY_NO_EXPORT int PyArray_FillWithScalar \
+NPY_NO_EXPORT  int PyArray_FillWithScalar \
        (PyArrayObject *, PyObject *);
-NPY_NO_EXPORT npy_bool PyArray_CheckStrides \
-       (int, int, npy_intp, npy_intp, npy_intp *, npy_intp *);
-NPY_NO_EXPORT PyArray_Descr * PyArray_DescrNewByteorder \
+NPY_NO_EXPORT  npy_bool PyArray_CheckStrides \
+       (int, int, npy_intp, npy_intp, npy_intp const *, npy_intp const *);
+NPY_NO_EXPORT  PyArray_Descr * PyArray_DescrNewByteorder \
        (PyArray_Descr *, char);
-NPY_NO_EXPORT PyObject * PyArray_IterAllButAxis \
+NPY_NO_EXPORT  PyObject * PyArray_IterAllButAxis \
        (PyObject *, int *);
-NPY_NO_EXPORT PyObject * PyArray_CheckFromAny \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(2) PyObject * PyArray_CheckFromAny \
        (PyObject *, PyArray_Descr *, int, int, int, PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_FromArray \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(2) PyObject * PyArray_FromArray \
        (PyArrayObject *, PyArray_Descr *, int);
-NPY_NO_EXPORT PyObject * PyArray_FromInterface \
+NPY_NO_EXPORT  PyObject * PyArray_FromInterface \
        (PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_FromStructInterface \
+NPY_NO_EXPORT  PyObject * PyArray_FromStructInterface \
        (PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_FromArrayAttr \
+NPY_NO_EXPORT  PyObject * PyArray_FromArrayAttr \
        (PyObject *, PyArray_Descr *, PyObject *);
-NPY_NO_EXPORT NPY_SCALARKIND PyArray_ScalarKind \
+NPY_NO_EXPORT  NPY_SCALARKIND PyArray_ScalarKind \
        (int, PyArrayObject **);
-NPY_NO_EXPORT int PyArray_CanCoerceScalar \
+NPY_NO_EXPORT  int PyArray_CanCoerceScalar \
        (int, int, NPY_SCALARKIND);
-NPY_NO_EXPORT PyObject * PyArray_NewFlagsObject \
+NPY_NO_EXPORT  PyObject * PyArray_NewFlagsObject \
        (PyObject *);
-NPY_NO_EXPORT npy_bool PyArray_CanCastScalar \
+NPY_NO_EXPORT  npy_bool PyArray_CanCastScalar \
        (PyTypeObject *, PyTypeObject *);
-NPY_NO_EXPORT int PyArray_CompareUCS4 \
-       (npy_ucs4 *, npy_ucs4 *, size_t);
-NPY_NO_EXPORT int PyArray_RemoveSmallest \
+NPY_NO_EXPORT  int PyArray_CompareUCS4 \
+       (npy_ucs4 const *, npy_ucs4 const *, size_t);
+NPY_NO_EXPORT  int PyArray_RemoveSmallest \
        (PyArrayMultiIterObject *);
-NPY_NO_EXPORT int PyArray_ElementStrides \
+NPY_NO_EXPORT  int PyArray_ElementStrides \
        (PyObject *);
-NPY_NO_EXPORT void PyArray_Item_INCREF \
+NPY_NO_EXPORT  void PyArray_Item_INCREF \
        (char *, PyArray_Descr *);
-NPY_NO_EXPORT void PyArray_Item_XDECREF \
+NPY_NO_EXPORT  void PyArray_Item_XDECREF \
        (char *, PyArray_Descr *);
-NPY_NO_EXPORT PyObject * PyArray_FieldNames \
+NPY_NO_EXPORT  PyObject * PyArray_FieldNames \
        (PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_Transpose \
+NPY_NO_EXPORT  PyObject * PyArray_Transpose \
        (PyArrayObject *, PyArray_Dims *);
-NPY_NO_EXPORT PyObject * PyArray_TakeFrom \
+NPY_NO_EXPORT  PyObject * PyArray_TakeFrom \
        (PyArrayObject *, PyObject *, int, PyArrayObject *, NPY_CLIPMODE);
-NPY_NO_EXPORT PyObject * PyArray_PutTo \
+NPY_NO_EXPORT  PyObject * PyArray_PutTo \
        (PyArrayObject *, PyObject*, PyObject *, NPY_CLIPMODE);
-NPY_NO_EXPORT PyObject * PyArray_PutMask \
+NPY_NO_EXPORT  PyObject * PyArray_PutMask \
        (PyArrayObject *, PyObject*, PyObject*);
-NPY_NO_EXPORT PyObject * PyArray_Repeat \
+NPY_NO_EXPORT  PyObject * PyArray_Repeat \
        (PyArrayObject *, PyObject *, int);
-NPY_NO_EXPORT PyObject * PyArray_Choose \
+NPY_NO_EXPORT  PyObject * PyArray_Choose \
        (PyArrayObject *, PyObject *, PyArrayObject *, NPY_CLIPMODE);
-NPY_NO_EXPORT int PyArray_Sort \
+NPY_NO_EXPORT  int PyArray_Sort \
        (PyArrayObject *, int, NPY_SORTKIND);
-NPY_NO_EXPORT PyObject * PyArray_ArgSort \
+NPY_NO_EXPORT  PyObject * PyArray_ArgSort \
        (PyArrayObject *, int, NPY_SORTKIND);
-NPY_NO_EXPORT PyObject * PyArray_SearchSorted \
+NPY_NO_EXPORT  PyObject * PyArray_SearchSorted \
        (PyArrayObject *, PyObject *, NPY_SEARCHSIDE, PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_ArgMax \
+NPY_NO_EXPORT  PyObject * PyArray_ArgMax \
        (PyArrayObject *, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_ArgMin \
+NPY_NO_EXPORT  PyObject * PyArray_ArgMin \
        (PyArrayObject *, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Reshape \
+NPY_NO_EXPORT  PyObject * PyArray_Reshape \
        (PyArrayObject *, PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_Newshape \
+NPY_NO_EXPORT  PyObject * PyArray_Newshape \
        (PyArrayObject *, PyArray_Dims *, NPY_ORDER);
-NPY_NO_EXPORT PyObject * PyArray_Squeeze \
+NPY_NO_EXPORT  PyObject * PyArray_Squeeze \
        (PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_View \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(2) PyObject * PyArray_View \
        (PyArrayObject *, PyArray_Descr *, PyTypeObject *);
-NPY_NO_EXPORT PyObject * PyArray_SwapAxes \
+NPY_NO_EXPORT  PyObject * PyArray_SwapAxes \
        (PyArrayObject *, int, int);
-NPY_NO_EXPORT PyObject * PyArray_Max \
+NPY_NO_EXPORT  PyObject * PyArray_Max \
        (PyArrayObject *, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Min \
+NPY_NO_EXPORT  PyObject * PyArray_Min \
        (PyArrayObject *, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Ptp \
+NPY_NO_EXPORT  PyObject * PyArray_Ptp \
        (PyArrayObject *, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Mean \
+NPY_NO_EXPORT  PyObject * PyArray_Mean \
        (PyArrayObject *, int, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Trace \
+NPY_NO_EXPORT  PyObject * PyArray_Trace \
        (PyArrayObject *, int, int, int, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Diagonal \
+NPY_NO_EXPORT  PyObject * PyArray_Diagonal \
        (PyArrayObject *, int, int, int);
-NPY_NO_EXPORT PyObject * PyArray_Clip \
+NPY_NO_EXPORT  PyObject * PyArray_Clip \
        (PyArrayObject *, PyObject *, PyObject *, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Conjugate \
+NPY_NO_EXPORT  PyObject * PyArray_Conjugate \
        (PyArrayObject *, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Nonzero \
+NPY_NO_EXPORT  PyObject * PyArray_Nonzero \
        (PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Std \
+NPY_NO_EXPORT  PyObject * PyArray_Std \
        (PyArrayObject *, int, int, PyArrayObject *, int);
-NPY_NO_EXPORT PyObject * PyArray_Sum \
+NPY_NO_EXPORT  PyObject * PyArray_Sum \
        (PyArrayObject *, int, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_CumSum \
+NPY_NO_EXPORT  PyObject * PyArray_CumSum \
        (PyArrayObject *, int, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Prod \
+NPY_NO_EXPORT  PyObject * PyArray_Prod \
        (PyArrayObject *, int, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_CumProd \
+NPY_NO_EXPORT  PyObject * PyArray_CumProd \
        (PyArrayObject *, int, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_All \
+NPY_NO_EXPORT  PyObject * PyArray_All \
        (PyArrayObject *, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Any \
+NPY_NO_EXPORT  PyObject * PyArray_Any \
        (PyArrayObject *, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Compress \
+NPY_NO_EXPORT  PyObject * PyArray_Compress \
        (PyArrayObject *, PyObject *, int, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_Flatten \
+NPY_NO_EXPORT  PyObject * PyArray_Flatten \
        (PyArrayObject *, NPY_ORDER);
-NPY_NO_EXPORT PyObject * PyArray_Ravel \
+NPY_NO_EXPORT  PyObject * PyArray_Ravel \
        (PyArrayObject *, NPY_ORDER);
-NPY_NO_EXPORT npy_intp PyArray_MultiplyList \
-       (npy_intp *, int);
-NPY_NO_EXPORT int PyArray_MultiplyIntList \
-       (int *, int);
-NPY_NO_EXPORT void * PyArray_GetPtr \
-       (PyArrayObject *, npy_intp*);
-NPY_NO_EXPORT int PyArray_CompareLists \
-       (npy_intp *, npy_intp *, int);
-NPY_NO_EXPORT int PyArray_AsCArray \
+NPY_NO_EXPORT  npy_intp PyArray_MultiplyList \
+       (npy_intp const *, int);
+NPY_NO_EXPORT  int PyArray_MultiplyIntList \
+       (int const *, int);
+NPY_NO_EXPORT  void * PyArray_GetPtr \
+       (PyArrayObject *, npy_intp const*);
+NPY_NO_EXPORT  int PyArray_CompareLists \
+       (npy_intp const *, npy_intp const *, int);
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(5) int PyArray_AsCArray \
        (PyObject **, void *, npy_intp *, int, PyArray_Descr*);
-NPY_NO_EXPORT int PyArray_As1D \
-       (PyObject **, char **, int *, int);
-NPY_NO_EXPORT int PyArray_As2D \
-       (PyObject **, char ***, int *, int *, int);
-NPY_NO_EXPORT int PyArray_Free \
+NPY_NO_EXPORT  int PyArray_As1D \
+       (PyObject **NPY_UNUSED(op), char **NPY_UNUSED(ptr), int *NPY_UNUSED(d1), int NPY_UNUSED(typecode));
+NPY_NO_EXPORT  int PyArray_As2D \
+       (PyObject **NPY_UNUSED(op), char ***NPY_UNUSED(ptr), int *NPY_UNUSED(d1), int *NPY_UNUSED(d2), int NPY_UNUSED(typecode));
+NPY_NO_EXPORT  int PyArray_Free \
        (PyObject *, void *);
-NPY_NO_EXPORT int PyArray_Converter \
+NPY_NO_EXPORT  int PyArray_Converter \
        (PyObject *, PyObject **);
-NPY_NO_EXPORT int PyArray_IntpFromSequence \
+NPY_NO_EXPORT  int PyArray_IntpFromSequence \
        (PyObject *, npy_intp *, int);
-NPY_NO_EXPORT PyObject * PyArray_Concatenate \
+NPY_NO_EXPORT  PyObject * PyArray_Concatenate \
        (PyObject *, int);
-NPY_NO_EXPORT PyObject * PyArray_InnerProduct \
+NPY_NO_EXPORT  PyObject * PyArray_InnerProduct \
        (PyObject *, PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_MatrixProduct \
+NPY_NO_EXPORT  PyObject * PyArray_MatrixProduct \
        (PyObject *, PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_CopyAndTranspose \
+NPY_NO_EXPORT  PyObject * PyArray_CopyAndTranspose \
        (PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_Correlate \
+NPY_NO_EXPORT  PyObject * PyArray_Correlate \
        (PyObject *, PyObject *, int);
-NPY_NO_EXPORT int PyArray_TypestrConvert \
+NPY_NO_EXPORT  int PyArray_TypestrConvert \
        (int, int);
-NPY_NO_EXPORT int PyArray_DescrConverter \
+NPY_NO_EXPORT  int PyArray_DescrConverter \
        (PyObject *, PyArray_Descr **);
-NPY_NO_EXPORT int PyArray_DescrConverter2 \
+NPY_NO_EXPORT  int PyArray_DescrConverter2 \
        (PyObject *, PyArray_Descr **);
-NPY_NO_EXPORT int PyArray_IntpConverter \
+NPY_NO_EXPORT  int PyArray_IntpConverter \
        (PyObject *, PyArray_Dims *);
-NPY_NO_EXPORT int PyArray_BufferConverter \
+NPY_NO_EXPORT  int PyArray_BufferConverter \
        (PyObject *, PyArray_Chunk *);
-NPY_NO_EXPORT int PyArray_AxisConverter \
+NPY_NO_EXPORT  int PyArray_AxisConverter \
        (PyObject *, int *);
-NPY_NO_EXPORT int PyArray_BoolConverter \
+NPY_NO_EXPORT  int PyArray_BoolConverter \
        (PyObject *, npy_bool *);
-NPY_NO_EXPORT int PyArray_ByteorderConverter \
+NPY_NO_EXPORT  int PyArray_ByteorderConverter \
        (PyObject *, char *);
-NPY_NO_EXPORT int PyArray_OrderConverter \
+NPY_NO_EXPORT  int PyArray_OrderConverter \
        (PyObject *, NPY_ORDER *);
-NPY_NO_EXPORT unsigned char PyArray_EquivTypes \
+NPY_NO_EXPORT  unsigned char PyArray_EquivTypes \
        (PyArray_Descr *, PyArray_Descr *);
-NPY_NO_EXPORT PyObject * PyArray_Zeros \
-       (int, npy_intp *, PyArray_Descr *, int);
-NPY_NO_EXPORT PyObject * PyArray_Empty \
-       (int, npy_intp *, PyArray_Descr *, int);
-NPY_NO_EXPORT PyObject * PyArray_Where \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(3) PyObject * PyArray_Zeros \
+       (int, npy_intp const *, PyArray_Descr *, int);
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(3) PyObject * PyArray_Empty \
+       (int, npy_intp const *, PyArray_Descr *, int);
+NPY_NO_EXPORT  PyObject * PyArray_Where \
        (PyObject *, PyObject *, PyObject *);
-NPY_NO_EXPORT PyObject * PyArray_Arange \
+NPY_NO_EXPORT  PyObject * PyArray_Arange \
        (double, double, double, int);
-NPY_NO_EXPORT PyObject * PyArray_ArangeObj \
+NPY_NO_EXPORT  PyObject * PyArray_ArangeObj \
        (PyObject *, PyObject *, PyObject *, PyArray_Descr *);
-NPY_NO_EXPORT int PyArray_SortkindConverter \
+NPY_NO_EXPORT  int PyArray_SortkindConverter \
        (PyObject *, NPY_SORTKIND *);
-NPY_NO_EXPORT PyObject * PyArray_LexSort \
+NPY_NO_EXPORT  PyObject * PyArray_LexSort \
        (PyObject *, int);
-NPY_NO_EXPORT PyObject * PyArray_Round \
+NPY_NO_EXPORT  PyObject * PyArray_Round \
        (PyArrayObject *, int, PyArrayObject *);
-NPY_NO_EXPORT unsigned char PyArray_EquivTypenums \
+NPY_NO_EXPORT  unsigned char PyArray_EquivTypenums \
        (int, int);
-NPY_NO_EXPORT int PyArray_RegisterDataType \
+NPY_NO_EXPORT  int PyArray_RegisterDataType \
        (PyArray_Descr *);
-NPY_NO_EXPORT int PyArray_RegisterCastFunc \
+NPY_NO_EXPORT  int PyArray_RegisterCastFunc \
        (PyArray_Descr *, int, PyArray_VectorUnaryFunc *);
-NPY_NO_EXPORT int PyArray_RegisterCanCast \
+NPY_NO_EXPORT  int PyArray_RegisterCanCast \
        (PyArray_Descr *, int, NPY_SCALARKIND);
-NPY_NO_EXPORT void PyArray_InitArrFuncs \
+NPY_NO_EXPORT  void PyArray_InitArrFuncs \
        (PyArray_ArrFuncs *);
-NPY_NO_EXPORT PyObject * PyArray_IntTupleFromIntp \
-       (int, npy_intp *);
-NPY_NO_EXPORT int PyArray_TypeNumFromName \
-       (char *);
-NPY_NO_EXPORT int PyArray_ClipmodeConverter \
+NPY_NO_EXPORT  PyObject * PyArray_IntTupleFromIntp \
+       (int, npy_intp const *);
+NPY_NO_EXPORT  int PyArray_TypeNumFromName \
+       (char const *);
+NPY_NO_EXPORT  int PyArray_ClipmodeConverter \
        (PyObject *, NPY_CLIPMODE *);
-NPY_NO_EXPORT int PyArray_OutputConverter \
+NPY_NO_EXPORT  int PyArray_OutputConverter \
        (PyObject *, PyArrayObject **);
-NPY_NO_EXPORT PyObject * PyArray_BroadcastToShape \
+NPY_NO_EXPORT  PyObject * PyArray_BroadcastToShape \
        (PyObject *, npy_intp *, int);
-NPY_NO_EXPORT void _PyArray_SigintHandler \
+NPY_NO_EXPORT  void _PyArray_SigintHandler \
        (int);
-NPY_NO_EXPORT void* _PyArray_GetSigintBuf \
+NPY_NO_EXPORT  void* _PyArray_GetSigintBuf \
        (void);
-NPY_NO_EXPORT int PyArray_DescrAlignConverter \
+NPY_NO_EXPORT  int PyArray_DescrAlignConverter \
        (PyObject *, PyArray_Descr **);
-NPY_NO_EXPORT int PyArray_DescrAlignConverter2 \
+NPY_NO_EXPORT  int PyArray_DescrAlignConverter2 \
        (PyObject *, PyArray_Descr **);
-NPY_NO_EXPORT int PyArray_SearchsideConverter \
+NPY_NO_EXPORT  int PyArray_SearchsideConverter \
        (PyObject *, void *);
-NPY_NO_EXPORT PyObject * PyArray_CheckAxis \
+NPY_NO_EXPORT  PyObject * PyArray_CheckAxis \
        (PyArrayObject *, int *, int);
-NPY_NO_EXPORT npy_intp PyArray_OverflowMultiplyList \
-       (npy_intp *, int);
-NPY_NO_EXPORT int PyArray_CompareString \
-       (char *, char *, size_t);
-NPY_NO_EXPORT PyObject * PyArray_MultiIterFromObjects \
+NPY_NO_EXPORT  npy_intp PyArray_OverflowMultiplyList \
+       (npy_intp const *, int);
+NPY_NO_EXPORT  int PyArray_CompareString \
+       (const char *, const char *, size_t);
+NPY_NO_EXPORT  PyObject* PyArray_MultiIterFromObjects \
        (PyObject **, int, int, ...);
-NPY_NO_EXPORT int PyArray_GetEndianness \
+NPY_NO_EXPORT  int PyArray_GetEndianness \
        (void);
-NPY_NO_EXPORT unsigned int PyArray_GetNDArrayCFeatureVersion \
+NPY_NO_EXPORT  unsigned int PyArray_GetNDArrayCFeatureVersion \
        (void);
-NPY_NO_EXPORT PyObject * PyArray_Correlate2 \
+NPY_NO_EXPORT  PyObject * PyArray_Correlate2 \
        (PyObject *, PyObject *, int);
-NPY_NO_EXPORT PyObject* PyArray_NeighborhoodIterNew \
-       (PyArrayIterObject *, npy_intp *, int, PyArrayObject*);
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyTimeIntegerArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyTimeIntegerArrType_Type;
-#endif
+NPY_NO_EXPORT  PyObject* PyArray_NeighborhoodIterNew \
+       (PyArrayIterObject *, const npy_intp *, int, PyArrayObject*);
+extern NPY_NO_EXPORT PyTypeObject PyTimeIntegerArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyDatetimeArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyDatetimeArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyDatetimeArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyTimedeltaArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyTimedeltaArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyTimedeltaArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyHalfArrType_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyHalfArrType_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyHalfArrType_Type;
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject NpyIter_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject NpyIter_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject NpyIter_Type;
 
-NPY_NO_EXPORT void PyArray_SetDatetimeParseFunction \
-       (PyObject *);
-NPY_NO_EXPORT void PyArray_DatetimeToDatetimeStruct \
-       (npy_datetime, NPY_DATETIMEUNIT, npy_datetimestruct *);
-NPY_NO_EXPORT void PyArray_TimedeltaToTimedeltaStruct \
-       (npy_timedelta, NPY_DATETIMEUNIT, npy_timedeltastruct *);
-NPY_NO_EXPORT npy_datetime PyArray_DatetimeStructToDatetime \
-       (NPY_DATETIMEUNIT, npy_datetimestruct *);
-NPY_NO_EXPORT npy_datetime PyArray_TimedeltaStructToTimedelta \
-       (NPY_DATETIMEUNIT, npy_timedeltastruct *);
-NPY_NO_EXPORT NpyIter * NpyIter_New \
+NPY_NO_EXPORT  void PyArray_SetDatetimeParseFunction \
+       (PyObject *NPY_UNUSED(op));
+NPY_NO_EXPORT  void PyArray_DatetimeToDatetimeStruct \
+       (npy_datetime NPY_UNUSED(val), NPY_DATETIMEUNIT NPY_UNUSED(fr), npy_datetimestruct *);
+NPY_NO_EXPORT  void PyArray_TimedeltaToTimedeltaStruct \
+       (npy_timedelta NPY_UNUSED(val), NPY_DATETIMEUNIT NPY_UNUSED(fr), npy_timedeltastruct *);
+NPY_NO_EXPORT  npy_datetime PyArray_DatetimeStructToDatetime \
+       (NPY_DATETIMEUNIT NPY_UNUSED(fr), npy_datetimestruct *NPY_UNUSED(d));
+NPY_NO_EXPORT  npy_datetime PyArray_TimedeltaStructToTimedelta \
+       (NPY_DATETIMEUNIT NPY_UNUSED(fr), npy_timedeltastruct *NPY_UNUSED(d));
+NPY_NO_EXPORT  NpyIter * NpyIter_New \
        (PyArrayObject *, npy_uint32, NPY_ORDER, NPY_CASTING, PyArray_Descr*);
-NPY_NO_EXPORT NpyIter * NpyIter_MultiNew \
+NPY_NO_EXPORT  NpyIter * NpyIter_MultiNew \
        (int, PyArrayObject **, npy_uint32, NPY_ORDER, NPY_CASTING, npy_uint32 *, PyArray_Descr **);
-NPY_NO_EXPORT NpyIter * NpyIter_AdvancedNew \
+NPY_NO_EXPORT  NpyIter * NpyIter_AdvancedNew \
        (int, PyArrayObject **, npy_uint32, NPY_ORDER, NPY_CASTING, npy_uint32 *, PyArray_Descr **, int, int **, npy_intp *, npy_intp);
-NPY_NO_EXPORT NpyIter * NpyIter_Copy \
+NPY_NO_EXPORT  NpyIter * NpyIter_Copy \
        (NpyIter *);
-NPY_NO_EXPORT int NpyIter_Deallocate \
+NPY_NO_EXPORT  int NpyIter_Deallocate \
        (NpyIter *);
-NPY_NO_EXPORT npy_bool NpyIter_HasDelayedBufAlloc \
+NPY_NO_EXPORT  npy_bool NpyIter_HasDelayedBufAlloc \
        (NpyIter *);
-NPY_NO_EXPORT npy_bool NpyIter_HasExternalLoop \
+NPY_NO_EXPORT  npy_bool NpyIter_HasExternalLoop \
        (NpyIter *);
-NPY_NO_EXPORT int NpyIter_EnableExternalLoop \
+NPY_NO_EXPORT  int NpyIter_EnableExternalLoop \
        (NpyIter *);
-NPY_NO_EXPORT npy_intp * NpyIter_GetInnerStrideArray \
+NPY_NO_EXPORT  npy_intp * NpyIter_GetInnerStrideArray \
        (NpyIter *);
-NPY_NO_EXPORT npy_intp * NpyIter_GetInnerLoopSizePtr \
+NPY_NO_EXPORT  npy_intp * NpyIter_GetInnerLoopSizePtr \
        (NpyIter *);
-NPY_NO_EXPORT int NpyIter_Reset \
+NPY_NO_EXPORT  int NpyIter_Reset \
        (NpyIter *, char **);
-NPY_NO_EXPORT int NpyIter_ResetBasePointers \
+NPY_NO_EXPORT  int NpyIter_ResetBasePointers \
        (NpyIter *, char **, char **);
-NPY_NO_EXPORT int NpyIter_ResetToIterIndexRange \
+NPY_NO_EXPORT  int NpyIter_ResetToIterIndexRange \
        (NpyIter *, npy_intp, npy_intp, char **);
-NPY_NO_EXPORT int NpyIter_GetNDim \
+NPY_NO_EXPORT  int NpyIter_GetNDim \
        (NpyIter *);
-NPY_NO_EXPORT int NpyIter_GetNOp \
+NPY_NO_EXPORT  int NpyIter_GetNOp \
        (NpyIter *);
-NPY_NO_EXPORT NpyIter_IterNextFunc * NpyIter_GetIterNext \
+NPY_NO_EXPORT  NpyIter_IterNextFunc * NpyIter_GetIterNext \
        (NpyIter *, char **);
-NPY_NO_EXPORT npy_intp NpyIter_GetIterSize \
+NPY_NO_EXPORT  npy_intp NpyIter_GetIterSize \
        (NpyIter *);
-NPY_NO_EXPORT void NpyIter_GetIterIndexRange \
+NPY_NO_EXPORT  void NpyIter_GetIterIndexRange \
        (NpyIter *, npy_intp *, npy_intp *);
-NPY_NO_EXPORT npy_intp NpyIter_GetIterIndex \
+NPY_NO_EXPORT  npy_intp NpyIter_GetIterIndex \
        (NpyIter *);
-NPY_NO_EXPORT int NpyIter_GotoIterIndex \
+NPY_NO_EXPORT  int NpyIter_GotoIterIndex \
        (NpyIter *, npy_intp);
-NPY_NO_EXPORT npy_bool NpyIter_HasMultiIndex \
+NPY_NO_EXPORT  npy_bool NpyIter_HasMultiIndex \
        (NpyIter *);
-NPY_NO_EXPORT int NpyIter_GetShape \
+NPY_NO_EXPORT  int NpyIter_GetShape \
        (NpyIter *, npy_intp *);
-NPY_NO_EXPORT NpyIter_GetMultiIndexFunc * NpyIter_GetGetMultiIndex \
+NPY_NO_EXPORT  NpyIter_GetMultiIndexFunc * NpyIter_GetGetMultiIndex \
        (NpyIter *, char **);
-NPY_NO_EXPORT int NpyIter_GotoMultiIndex \
-       (NpyIter *, npy_intp *);
-NPY_NO_EXPORT int NpyIter_RemoveMultiIndex \
+NPY_NO_EXPORT  int NpyIter_GotoMultiIndex \
+       (NpyIter *, npy_intp const *);
+NPY_NO_EXPORT  int NpyIter_RemoveMultiIndex \
        (NpyIter *);
-NPY_NO_EXPORT npy_bool NpyIter_HasIndex \
+NPY_NO_EXPORT  npy_bool NpyIter_HasIndex \
        (NpyIter *);
-NPY_NO_EXPORT npy_bool NpyIter_IsBuffered \
+NPY_NO_EXPORT  npy_bool NpyIter_IsBuffered \
        (NpyIter *);
-NPY_NO_EXPORT npy_bool NpyIter_IsGrowInner \
+NPY_NO_EXPORT  npy_bool NpyIter_IsGrowInner \
        (NpyIter *);
-NPY_NO_EXPORT npy_intp NpyIter_GetBufferSize \
+NPY_NO_EXPORT  npy_intp NpyIter_GetBufferSize \
        (NpyIter *);
-NPY_NO_EXPORT npy_intp * NpyIter_GetIndexPtr \
+NPY_NO_EXPORT  npy_intp * NpyIter_GetIndexPtr \
        (NpyIter *);
-NPY_NO_EXPORT int NpyIter_GotoIndex \
+NPY_NO_EXPORT  int NpyIter_GotoIndex \
        (NpyIter *, npy_intp);
-NPY_NO_EXPORT char ** NpyIter_GetDataPtrArray \
+NPY_NO_EXPORT  char ** NpyIter_GetDataPtrArray \
        (NpyIter *);
-NPY_NO_EXPORT PyArray_Descr ** NpyIter_GetDescrArray \
+NPY_NO_EXPORT  PyArray_Descr ** NpyIter_GetDescrArray \
        (NpyIter *);
-NPY_NO_EXPORT PyArrayObject ** NpyIter_GetOperandArray \
+NPY_NO_EXPORT  PyArrayObject ** NpyIter_GetOperandArray \
        (NpyIter *);
-NPY_NO_EXPORT PyArrayObject * NpyIter_GetIterView \
+NPY_NO_EXPORT  PyArrayObject * NpyIter_GetIterView \
        (NpyIter *, npy_intp);
-NPY_NO_EXPORT void NpyIter_GetReadFlags \
+NPY_NO_EXPORT  void NpyIter_GetReadFlags \
        (NpyIter *, char *);
-NPY_NO_EXPORT void NpyIter_GetWriteFlags \
+NPY_NO_EXPORT  void NpyIter_GetWriteFlags \
        (NpyIter *, char *);
-NPY_NO_EXPORT void NpyIter_DebugPrint \
+NPY_NO_EXPORT  void NpyIter_DebugPrint \
        (NpyIter *);
-NPY_NO_EXPORT npy_bool NpyIter_IterationNeedsAPI \
+NPY_NO_EXPORT  npy_bool NpyIter_IterationNeedsAPI \
        (NpyIter *);
-NPY_NO_EXPORT void NpyIter_GetInnerFixedStrideArray \
+NPY_NO_EXPORT  void NpyIter_GetInnerFixedStrideArray \
        (NpyIter *, npy_intp *);
-NPY_NO_EXPORT int NpyIter_RemoveAxis \
+NPY_NO_EXPORT  int NpyIter_RemoveAxis \
        (NpyIter *, int);
-NPY_NO_EXPORT npy_intp * NpyIter_GetAxisStrideArray \
+NPY_NO_EXPORT  npy_intp * NpyIter_GetAxisStrideArray \
        (NpyIter *, int);
-NPY_NO_EXPORT npy_bool NpyIter_RequiresBuffering \
+NPY_NO_EXPORT  npy_bool NpyIter_RequiresBuffering \
        (NpyIter *);
-NPY_NO_EXPORT char ** NpyIter_GetInitialDataPtrArray \
+NPY_NO_EXPORT  char ** NpyIter_GetInitialDataPtrArray \
        (NpyIter *);
-NPY_NO_EXPORT int NpyIter_CreateCompatibleStrides \
+NPY_NO_EXPORT  int NpyIter_CreateCompatibleStrides \
        (NpyIter *, npy_intp, npy_intp *);
-NPY_NO_EXPORT int PyArray_CastingConverter \
+NPY_NO_EXPORT  int PyArray_CastingConverter \
        (PyObject *, NPY_CASTING *);
-NPY_NO_EXPORT npy_intp PyArray_CountNonzero \
+NPY_NO_EXPORT  npy_intp PyArray_CountNonzero \
        (PyArrayObject *);
-NPY_NO_EXPORT PyArray_Descr * PyArray_PromoteTypes \
+NPY_NO_EXPORT  PyArray_Descr * PyArray_PromoteTypes \
        (PyArray_Descr *, PyArray_Descr *);
-NPY_NO_EXPORT PyArray_Descr * PyArray_MinScalarType \
+NPY_NO_EXPORT  PyArray_Descr * PyArray_MinScalarType \
        (PyArrayObject *);
-NPY_NO_EXPORT PyArray_Descr * PyArray_ResultType \
+NPY_NO_EXPORT  PyArray_Descr * PyArray_ResultType \
        (npy_intp, PyArrayObject **, npy_intp, PyArray_Descr **);
-NPY_NO_EXPORT npy_bool PyArray_CanCastArrayTo \
+NPY_NO_EXPORT  npy_bool PyArray_CanCastArrayTo \
        (PyArrayObject *, PyArray_Descr *, NPY_CASTING);
-NPY_NO_EXPORT npy_bool PyArray_CanCastTypeTo \
+NPY_NO_EXPORT  npy_bool PyArray_CanCastTypeTo \
        (PyArray_Descr *, PyArray_Descr *, NPY_CASTING);
-NPY_NO_EXPORT PyArrayObject * PyArray_EinsteinSum \
+NPY_NO_EXPORT  PyArrayObject * PyArray_EinsteinSum \
        (char *, npy_intp, PyArrayObject **, PyArray_Descr *, NPY_ORDER, NPY_CASTING, PyArrayObject *);
-NPY_NO_EXPORT PyObject * PyArray_NewLikeArray \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(3) NPY_GCC_NONNULL(1) PyObject * PyArray_NewLikeArray \
        (PyArrayObject *, NPY_ORDER, PyArray_Descr *, int);
-NPY_NO_EXPORT int PyArray_GetArrayParamsFromObject \
+NPY_NO_EXPORT  int PyArray_GetArrayParamsFromObject \
        (PyObject *, PyArray_Descr *, npy_bool, PyArray_Descr **, int *, npy_intp *, PyArrayObject **, PyObject *);
-NPY_NO_EXPORT int PyArray_ConvertClipmodeSequence \
+NPY_NO_EXPORT  int PyArray_ConvertClipmodeSequence \
        (PyObject *, NPY_CLIPMODE *, int);
-NPY_NO_EXPORT PyObject * PyArray_MatrixProduct2 \
+NPY_NO_EXPORT  PyObject * PyArray_MatrixProduct2 \
        (PyObject *, PyObject *, PyArrayObject*);
-NPY_NO_EXPORT npy_bool NpyIter_IsFirstVisit \
+NPY_NO_EXPORT  npy_bool NpyIter_IsFirstVisit \
        (NpyIter *, int);
-NPY_NO_EXPORT int PyArray_SetBaseObject \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(2) int PyArray_SetBaseObject \
        (PyArrayObject *, PyObject *);
-NPY_NO_EXPORT void PyArray_CreateSortedStridePerm \
-       (int, npy_intp *, npy_stride_sort_item *);
-NPY_NO_EXPORT void PyArray_RemoveAxesInPlace \
-       (PyArrayObject *, npy_bool *);
-NPY_NO_EXPORT void PyArray_DebugPrint \
+NPY_NO_EXPORT  void PyArray_CreateSortedStridePerm \
+       (int, npy_intp const *, npy_stride_sort_item *);
+NPY_NO_EXPORT  void PyArray_RemoveAxesInPlace \
+       (PyArrayObject *, const npy_bool *);
+NPY_NO_EXPORT  void PyArray_DebugPrint \
        (PyArrayObject *);
-NPY_NO_EXPORT int PyArray_FailUnlessWriteable \
+NPY_NO_EXPORT  int PyArray_FailUnlessWriteable \
        (PyArrayObject *, const char *);
-NPY_NO_EXPORT int PyArray_SetUpdateIfCopyBase \
+NPY_NO_EXPORT NPY_STEALS_REF_TO_ARG(2) int PyArray_SetUpdateIfCopyBase \
        (PyArrayObject *, PyArrayObject *);
-NPY_NO_EXPORT void * PyDataMem_NEW \
+NPY_NO_EXPORT  void * PyDataMem_NEW \
        (size_t);
-NPY_NO_EXPORT void PyDataMem_FREE \
+NPY_NO_EXPORT  void PyDataMem_FREE \
        (void *);
-NPY_NO_EXPORT void * PyDataMem_RENEW \
+NPY_NO_EXPORT  void * PyDataMem_RENEW \
        (void *, size_t);
-NPY_NO_EXPORT PyDataMem_EventHookFunc * PyDataMem_SetEventHook \
+NPY_NO_EXPORT  PyDataMem_EventHookFunc * PyDataMem_SetEventHook \
        (PyDataMem_EventHookFunc *, void *, void **);
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT NPY_CASTING NPY_DEFAULT_ASSIGN_CASTING;
-#else
-    NPY_NO_EXPORT NPY_CASTING NPY_DEFAULT_ASSIGN_CASTING;
-#endif
+extern NPY_NO_EXPORT NPY_CASTING NPY_DEFAULT_ASSIGN_CASTING;
 
+NPY_NO_EXPORT  void PyArray_MapIterSwapAxes \
+       (PyArrayMapIterObject *, PyArrayObject **, int);
+NPY_NO_EXPORT  PyObject * PyArray_MapIterArray \
+       (PyArrayObject *, PyObject *);
+NPY_NO_EXPORT  void PyArray_MapIterNext \
+       (PyArrayMapIterObject *);
+NPY_NO_EXPORT  int PyArray_Partition \
+       (PyArrayObject *, PyArrayObject *, int, NPY_SELECTKIND);
+NPY_NO_EXPORT  PyObject * PyArray_ArgPartition \
+       (PyArrayObject *, PyArrayObject *, int, NPY_SELECTKIND);
+NPY_NO_EXPORT  int PyArray_SelectkindConverter \
+       (PyObject *, NPY_SELECTKIND *);
+NPY_NO_EXPORT  void * PyDataMem_NEW_ZEROED \
+       (size_t, size_t);
+NPY_NO_EXPORT NPY_GCC_NONNULL(1) int PyArray_CheckAnyScalarExact \
+       (PyObject *);
+NPY_NO_EXPORT  PyObject * PyArray_MapIterArrayCopyIfOverlap \
+       (PyArrayObject *, PyObject *, int, PyArrayObject *);
+NPY_NO_EXPORT  int PyArray_ResolveWritebackIfCopy \
+       (PyArrayObject *);
+NPY_NO_EXPORT  int PyArray_SetWritebackIfCopyBase \
+       (PyArrayObject *, PyArrayObject *);
 
 #else
 
@@ -923,10 +759,10 @@ static void **PyArray_API=NULL;
         (*(PyArray_VectorUnaryFunc * (*)(PyArray_Descr *, int)) \
          PyArray_API[66])
 #define PyArray_FromDims \
-        (*(PyObject * (*)(int, int *, int)) \
+        (*(PyObject * (*)(int NPY_UNUSED(nd), int *NPY_UNUSED(d), int NPY_UNUSED(type))) \
          PyArray_API[67])
 #define PyArray_FromDimsAndDataAndDescr \
-        (*(PyObject * (*)(int, int *, PyArray_Descr *, char *)) \
+        (*(PyObject * (*)(int NPY_UNUSED(nd), int *NPY_UNUSED(d), PyArray_Descr *, char *NPY_UNUSED(data))) \
          PyArray_API[68])
 #define PyArray_FromAny \
         (*(PyObject * (*)(PyObject *, PyArray_Descr *, int, int, int, PyObject *)) \
@@ -962,7 +798,7 @@ static void **PyArray_API=NULL;
         (*(PyObject * (*)(PyArrayObject *, npy_bool)) \
          PyArray_API[79])
 #define PyArray_Resize \
-        (*(PyObject * (*)(PyArrayObject *, PyArray_Dims *, int, NPY_ORDER)) \
+        (*(PyObject * (*)(PyArrayObject *, PyArray_Dims *, int, NPY_ORDER NPY_UNUSED(order))) \
          PyArray_API[80])
 #define PyArray_MoveInto \
         (*(int (*)(PyArrayObject *, PyArrayObject *)) \
@@ -1001,10 +837,10 @@ static void **PyArray_API=NULL;
         (*(void (*)(PyArrayObject *, int)) \
          PyArray_API[92])
 #define PyArray_New \
-        (*(PyObject * (*)(PyTypeObject *, int, npy_intp *, int, npy_intp *, void *, int, int, PyObject *)) \
+        (*(PyObject * (*)(PyTypeObject *, int, npy_intp const *, int, npy_intp const *, void *, int, int, PyObject *)) \
          PyArray_API[93])
 #define PyArray_NewFromDescr \
-        (*(PyObject * (*)(PyTypeObject *, PyArray_Descr *, int, npy_intp *, npy_intp *, void *, int, PyObject *)) \
+        (*(PyObject * (*)(PyTypeObject *, PyArray_Descr *, int, npy_intp const *, npy_intp const *, void *, int, PyObject *)) \
          PyArray_API[94])
 #define PyArray_DescrNew \
         (*(PyArray_Descr * (*)(PyArray_Descr *)) \
@@ -1019,7 +855,7 @@ static void **PyArray_API=NULL;
         (*(PyObject * (*)(PyObject *)) \
          PyArray_API[98])
 #define PyArray_MultiIterNew \
-        (*(PyObject * (*)(int, ...)) \
+        (*(PyObject* (*)(int, ...)) \
          PyArray_API[99])
 #define PyArray_PyIntAsInt \
         (*(int (*)(PyObject *)) \
@@ -1037,7 +873,7 @@ static void **PyArray_API=NULL;
         (*(int (*)(PyArrayObject *, PyObject *)) \
          PyArray_API[104])
 #define PyArray_CheckStrides \
-        (*(npy_bool (*)(int, int, npy_intp, npy_intp, npy_intp *, npy_intp *)) \
+        (*(npy_bool (*)(int, int, npy_intp, npy_intp, npy_intp const *, npy_intp const *)) \
          PyArray_API[105])
 #define PyArray_DescrNewByteorder \
         (*(PyArray_Descr * (*)(PyArray_Descr *, char)) \
@@ -1073,7 +909,7 @@ static void **PyArray_API=NULL;
         (*(npy_bool (*)(PyTypeObject *, PyTypeObject *)) \
          PyArray_API[116])
 #define PyArray_CompareUCS4 \
-        (*(int (*)(npy_ucs4 *, npy_ucs4 *, size_t)) \
+        (*(int (*)(npy_ucs4 const *, npy_ucs4 const *, size_t)) \
          PyArray_API[117])
 #define PyArray_RemoveSmallest \
         (*(int (*)(PyArrayMultiIterObject *)) \
@@ -1196,25 +1032,25 @@ static void **PyArray_API=NULL;
         (*(PyObject * (*)(PyArrayObject *, NPY_ORDER)) \
          PyArray_API[157])
 #define PyArray_MultiplyList \
-        (*(npy_intp (*)(npy_intp *, int)) \
+        (*(npy_intp (*)(npy_intp const *, int)) \
          PyArray_API[158])
 #define PyArray_MultiplyIntList \
-        (*(int (*)(int *, int)) \
+        (*(int (*)(int const *, int)) \
          PyArray_API[159])
 #define PyArray_GetPtr \
-        (*(void * (*)(PyArrayObject *, npy_intp*)) \
+        (*(void * (*)(PyArrayObject *, npy_intp const*)) \
          PyArray_API[160])
 #define PyArray_CompareLists \
-        (*(int (*)(npy_intp *, npy_intp *, int)) \
+        (*(int (*)(npy_intp const *, npy_intp const *, int)) \
          PyArray_API[161])
 #define PyArray_AsCArray \
         (*(int (*)(PyObject **, void *, npy_intp *, int, PyArray_Descr*)) \
          PyArray_API[162])
 #define PyArray_As1D \
-        (*(int (*)(PyObject **, char **, int *, int)) \
+        (*(int (*)(PyObject **NPY_UNUSED(op), char **NPY_UNUSED(ptr), int *NPY_UNUSED(d1), int NPY_UNUSED(typecode))) \
          PyArray_API[163])
 #define PyArray_As2D \
-        (*(int (*)(PyObject **, char ***, int *, int *, int)) \
+        (*(int (*)(PyObject **NPY_UNUSED(op), char ***NPY_UNUSED(ptr), int *NPY_UNUSED(d1), int *NPY_UNUSED(d2), int NPY_UNUSED(typecode))) \
          PyArray_API[164])
 #define PyArray_Free \
         (*(int (*)(PyObject *, void *)) \
@@ -1271,10 +1107,10 @@ static void **PyArray_API=NULL;
         (*(unsigned char (*)(PyArray_Descr *, PyArray_Descr *)) \
          PyArray_API[182])
 #define PyArray_Zeros \
-        (*(PyObject * (*)(int, npy_intp *, PyArray_Descr *, int)) \
+        (*(PyObject * (*)(int, npy_intp const *, PyArray_Descr *, int)) \
          PyArray_API[183])
 #define PyArray_Empty \
-        (*(PyObject * (*)(int, npy_intp *, PyArray_Descr *, int)) \
+        (*(PyObject * (*)(int, npy_intp const *, PyArray_Descr *, int)) \
          PyArray_API[184])
 #define PyArray_Where \
         (*(PyObject * (*)(PyObject *, PyObject *, PyObject *)) \
@@ -1310,10 +1146,10 @@ static void **PyArray_API=NULL;
         (*(void (*)(PyArray_ArrFuncs *)) \
          PyArray_API[195])
 #define PyArray_IntTupleFromIntp \
-        (*(PyObject * (*)(int, npy_intp *)) \
+        (*(PyObject * (*)(int, npy_intp const *)) \
          PyArray_API[196])
 #define PyArray_TypeNumFromName \
-        (*(int (*)(char *)) \
+        (*(int (*)(char const *)) \
          PyArray_API[197])
 #define PyArray_ClipmodeConverter \
         (*(int (*)(PyObject *, NPY_CLIPMODE *)) \
@@ -1343,13 +1179,13 @@ static void **PyArray_API=NULL;
         (*(PyObject * (*)(PyArrayObject *, int *, int)) \
          PyArray_API[206])
 #define PyArray_OverflowMultiplyList \
-        (*(npy_intp (*)(npy_intp *, int)) \
+        (*(npy_intp (*)(npy_intp const *, int)) \
          PyArray_API[207])
 #define PyArray_CompareString \
-        (*(int (*)(char *, char *, size_t)) \
+        (*(int (*)(const char *, const char *, size_t)) \
          PyArray_API[208])
 #define PyArray_MultiIterFromObjects \
-        (*(PyObject * (*)(PyObject **, int, int, ...)) \
+        (*(PyObject* (*)(PyObject **, int, int, ...)) \
          PyArray_API[209])
 #define PyArray_GetEndianness \
         (*(int (*)(void)) \
@@ -1361,7 +1197,7 @@ static void **PyArray_API=NULL;
         (*(PyObject * (*)(PyObject *, PyObject *, int)) \
          PyArray_API[212])
 #define PyArray_NeighborhoodIterNew \
-        (*(PyObject* (*)(PyArrayIterObject *, npy_intp *, int, PyArrayObject*)) \
+        (*(PyObject* (*)(PyArrayIterObject *, const npy_intp *, int, PyArrayObject*)) \
          PyArray_API[213])
 #define PyTimeIntegerArrType_Type (*(PyTypeObject *)PyArray_API[214])
 #define PyDatetimeArrType_Type (*(PyTypeObject *)PyArray_API[215])
@@ -1369,19 +1205,19 @@ static void **PyArray_API=NULL;
 #define PyHalfArrType_Type (*(PyTypeObject *)PyArray_API[217])
 #define NpyIter_Type (*(PyTypeObject *)PyArray_API[218])
 #define PyArray_SetDatetimeParseFunction \
-        (*(void (*)(PyObject *)) \
+        (*(void (*)(PyObject *NPY_UNUSED(op))) \
          PyArray_API[219])
 #define PyArray_DatetimeToDatetimeStruct \
-        (*(void (*)(npy_datetime, NPY_DATETIMEUNIT, npy_datetimestruct *)) \
+        (*(void (*)(npy_datetime NPY_UNUSED(val), NPY_DATETIMEUNIT NPY_UNUSED(fr), npy_datetimestruct *)) \
          PyArray_API[220])
 #define PyArray_TimedeltaToTimedeltaStruct \
-        (*(void (*)(npy_timedelta, NPY_DATETIMEUNIT, npy_timedeltastruct *)) \
+        (*(void (*)(npy_timedelta NPY_UNUSED(val), NPY_DATETIMEUNIT NPY_UNUSED(fr), npy_timedeltastruct *)) \
          PyArray_API[221])
 #define PyArray_DatetimeStructToDatetime \
-        (*(npy_datetime (*)(NPY_DATETIMEUNIT, npy_datetimestruct *)) \
+        (*(npy_datetime (*)(NPY_DATETIMEUNIT NPY_UNUSED(fr), npy_datetimestruct *NPY_UNUSED(d))) \
          PyArray_API[222])
 #define PyArray_TimedeltaStructToTimedelta \
-        (*(npy_datetime (*)(NPY_DATETIMEUNIT, npy_timedeltastruct *)) \
+        (*(npy_datetime (*)(NPY_DATETIMEUNIT NPY_UNUSED(fr), npy_timedeltastruct *NPY_UNUSED(d))) \
          PyArray_API[223])
 #define NpyIter_New \
         (*(NpyIter * (*)(PyArrayObject *, npy_uint32, NPY_ORDER, NPY_CASTING, PyArray_Descr*)) \
@@ -1453,7 +1289,7 @@ static void **PyArray_API=NULL;
         (*(NpyIter_GetMultiIndexFunc * (*)(NpyIter *, char **)) \
          PyArray_API[246])
 #define NpyIter_GotoMultiIndex \
-        (*(int (*)(NpyIter *, npy_intp *)) \
+        (*(int (*)(NpyIter *, npy_intp const *)) \
          PyArray_API[247])
 #define NpyIter_RemoveMultiIndex \
         (*(int (*)(NpyIter *)) \
@@ -1561,10 +1397,10 @@ static void **PyArray_API=NULL;
         (*(int (*)(PyArrayObject *, PyObject *)) \
          PyArray_API[282])
 #define PyArray_CreateSortedStridePerm \
-        (*(void (*)(int, npy_intp *, npy_stride_sort_item *)) \
+        (*(void (*)(int, npy_intp const *, npy_stride_sort_item *)) \
          PyArray_API[283])
 #define PyArray_RemoveAxesInPlace \
-        (*(void (*)(PyArrayObject *, npy_bool *)) \
+        (*(void (*)(PyArrayObject *, const npy_bool *)) \
          PyArray_API[284])
 #define PyArray_DebugPrint \
         (*(void (*)(PyArrayObject *)) \
@@ -1588,17 +1424,49 @@ static void **PyArray_API=NULL;
         (*(PyDataMem_EventHookFunc * (*)(PyDataMem_EventHookFunc *, void *, void **)) \
          PyArray_API[291])
 #define NPY_DEFAULT_ASSIGN_CASTING (*(NPY_CASTING *)PyArray_API[292])
+#define PyArray_MapIterSwapAxes \
+        (*(void (*)(PyArrayMapIterObject *, PyArrayObject **, int)) \
+         PyArray_API[293])
+#define PyArray_MapIterArray \
+        (*(PyObject * (*)(PyArrayObject *, PyObject *)) \
+         PyArray_API[294])
+#define PyArray_MapIterNext \
+        (*(void (*)(PyArrayMapIterObject *)) \
+         PyArray_API[295])
+#define PyArray_Partition \
+        (*(int (*)(PyArrayObject *, PyArrayObject *, int, NPY_SELECTKIND)) \
+         PyArray_API[296])
+#define PyArray_ArgPartition \
+        (*(PyObject * (*)(PyArrayObject *, PyArrayObject *, int, NPY_SELECTKIND)) \
+         PyArray_API[297])
+#define PyArray_SelectkindConverter \
+        (*(int (*)(PyObject *, NPY_SELECTKIND *)) \
+         PyArray_API[298])
+#define PyDataMem_NEW_ZEROED \
+        (*(void * (*)(size_t, size_t)) \
+         PyArray_API[299])
+#define PyArray_CheckAnyScalarExact \
+        (*(int (*)(PyObject *)) \
+         PyArray_API[300])
+#define PyArray_MapIterArrayCopyIfOverlap \
+        (*(PyObject * (*)(PyArrayObject *, PyObject *, int, PyArrayObject *)) \
+         PyArray_API[301])
+#define PyArray_ResolveWritebackIfCopy \
+        (*(int (*)(PyArrayObject *)) \
+         PyArray_API[302])
+#define PyArray_SetWritebackIfCopyBase \
+        (*(int (*)(PyArrayObject *, PyArrayObject *)) \
+         PyArray_API[303])
 
 #if !defined(NO_IMPORT_ARRAY) && !defined(NO_IMPORT)
 static int
 _import_array(void)
 {
   int st;
-  PyObject *numpy = PyImport_ImportModule("numpy.core.multiarray");
+  PyObject *numpy = PyImport_ImportModule("numpy.core._multiarray_umath");
   PyObject *c_api = NULL;
 
   if (numpy == NULL) {
-      PyErr_SetString(PyExc_ImportError, "numpy.core.multiarray failed to import");
       return -1;
   }
   c_api = PyObject_GetAttrString(numpy, "_ARRAY_API");
@@ -1608,21 +1476,12 @@ _import_array(void)
       return -1;
   }
 
-#if PY_VERSION_HEX >= 0x03000000
   if (!PyCapsule_CheckExact(c_api)) {
       PyErr_SetString(PyExc_RuntimeError, "_ARRAY_API is not PyCapsule object");
       Py_DECREF(c_api);
       return -1;
   }
   PyArray_API = (void **)PyCapsule_GetPointer(c_api, NULL);
-#else
-  if (!PyCObject_Check(c_api)) {
-      PyErr_SetString(PyExc_RuntimeError, "_ARRAY_API is not PyCObject object");
-      Py_DECREF(c_api);
-      return -1;
-  }
-  PyArray_API = (void **)PyCObject_AsVoidPtr(c_api);
-#endif
   Py_DECREF(c_api);
   if (PyArray_API == NULL) {
       PyErr_SetString(PyExc_RuntimeError, "_ARRAY_API is NULL pointer");
@@ -1632,13 +1491,13 @@ _import_array(void)
   /* Perform runtime check of C API version */
   if (NPY_VERSION != PyArray_GetNDArrayCVersion()) {
       PyErr_Format(PyExc_RuntimeError, "module compiled against "\
-             "ABI version %x but this version of numpy is %x", \
+             "ABI version 0x%x but this version of numpy is 0x%x", \
              (int) NPY_VERSION, (int) PyArray_GetNDArrayCVersion());
       return -1;
   }
   if (NPY_FEATURE_VERSION > PyArray_GetNDArrayCFeatureVersion()) {
       PyErr_Format(PyExc_RuntimeError, "module compiled against "\
-             "API version %x but this version of numpy is %x", \
+             "API version 0x%x but this version of numpy is 0x%x", \
              (int) NPY_FEATURE_VERSION, (int) PyArray_GetNDArrayCFeatureVersion());
       return -1;
   }
@@ -1669,13 +1528,7 @@ _import_array(void)
   return 0;
 }
 
-#if PY_VERSION_HEX >= 0x03000000
-#define NUMPY_IMPORT_ARRAY_RETVAL NULL
-#else
-#define NUMPY_IMPORT_ARRAY_RETVAL
-#endif
-
-#define import_array() {if (_import_array() < 0) {PyErr_Print(); PyErr_SetString(PyExc_ImportError, "numpy.core.multiarray failed to import"); return NUMPY_IMPORT_ARRAY_RETVAL; } }
+#define import_array() {if (_import_array() < 0) {PyErr_Print(); PyErr_SetString(PyExc_ImportError, "numpy.core.multiarray failed to import"); return NULL; } }
 
 #define import_array1(ret) {if (_import_array() < 0) {PyErr_Print(); PyErr_SetString(PyExc_ImportError, "numpy.core.multiarray failed to import"); return ret; } }
 
diff --git a/include/numpy/__ufunc_api.h b/include/numpy/__ufunc_api.h
index fd81d07b5..c14bbc837 100644
--- a/include/numpy/__ufunc_api.h
+++ b/include/numpy/__ufunc_api.h
@@ -1,98 +1,94 @@
 
 #ifdef _UMATHMODULE
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
 extern NPY_NO_EXPORT PyTypeObject PyUFunc_Type;
-#else
-NPY_NO_EXPORT PyTypeObject PyUFunc_Type;
-#endif
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-    extern NPY_NO_EXPORT PyTypeObject PyUFunc_Type;
-#else
-    NPY_NO_EXPORT PyTypeObject PyUFunc_Type;
-#endif
+extern NPY_NO_EXPORT PyTypeObject PyUFunc_Type;
 
-NPY_NO_EXPORT PyObject * PyUFunc_FromFuncAndData \
-       (PyUFuncGenericFunction *, void **, char *, int, int, int, int, char *, char *, int);
-NPY_NO_EXPORT int PyUFunc_RegisterLoopForType \
-       (PyUFuncObject *, int, PyUFuncGenericFunction, int *, void *);
-NPY_NO_EXPORT int PyUFunc_GenericFunction \
+NPY_NO_EXPORT  PyObject * PyUFunc_FromFuncAndData \
+       (PyUFuncGenericFunction *, void **, char *, int, int, int, int, const char *, const char *, int);
+NPY_NO_EXPORT  int PyUFunc_RegisterLoopForType \
+       (PyUFuncObject *, int, PyUFuncGenericFunction, const int *, void *);
+NPY_NO_EXPORT  int PyUFunc_GenericFunction \
        (PyUFuncObject *, PyObject *, PyObject *, PyArrayObject **);
-NPY_NO_EXPORT void PyUFunc_f_f_As_d_d \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_d_d \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_f_f \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_g_g \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_F_F_As_D_D \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_F_F \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_D_D \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_G_G \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_O_O \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_ff_f_As_dd_d \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_ff_f \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_dd_d \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_gg_g \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_FF_F_As_DD_D \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_DD_D \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_FF_F \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_GG_G \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_OO_O \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_O_O_method \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_OO_O_method \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_On_Om \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT int PyUFunc_GetPyValues \
+NPY_NO_EXPORT  void PyUFunc_f_f_As_d_d \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_d_d \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_f_f \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_g_g \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_F_F_As_D_D \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_F_F \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_D_D \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_G_G \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_O_O \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_ff_f_As_dd_d \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_ff_f \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_dd_d \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_gg_g \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_FF_F_As_DD_D \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_DD_D \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_FF_F \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_GG_G \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_OO_O \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_O_O_method \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_OO_O_method \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_On_Om \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  int PyUFunc_GetPyValues \
        (char *, int *, int *, PyObject **);
-NPY_NO_EXPORT int PyUFunc_checkfperr \
+NPY_NO_EXPORT  int PyUFunc_checkfperr \
        (int, PyObject *, int *);
-NPY_NO_EXPORT void PyUFunc_clearfperr \
+NPY_NO_EXPORT  void PyUFunc_clearfperr \
        (void);
-NPY_NO_EXPORT int PyUFunc_getfperr \
+NPY_NO_EXPORT  int PyUFunc_getfperr \
        (void);
-NPY_NO_EXPORT int PyUFunc_handlefperr \
+NPY_NO_EXPORT  int PyUFunc_handlefperr \
        (int, PyObject *, int, int *);
-NPY_NO_EXPORT int PyUFunc_ReplaceLoopBySignature \
-       (PyUFuncObject *, PyUFuncGenericFunction, int *, PyUFuncGenericFunction *);
-NPY_NO_EXPORT PyObject * PyUFunc_FromFuncAndDataAndSignature \
-       (PyUFuncGenericFunction *, void **, char *, int, int, int, int, char *, char *, int, const char *);
-NPY_NO_EXPORT int PyUFunc_SetUsesArraysAsData \
+NPY_NO_EXPORT  int PyUFunc_ReplaceLoopBySignature \
+       (PyUFuncObject *, PyUFuncGenericFunction, const int *, PyUFuncGenericFunction *);
+NPY_NO_EXPORT  PyObject * PyUFunc_FromFuncAndDataAndSignature \
+       (PyUFuncGenericFunction *, void **, char *, int, int, int, int, const char *, const char *, int, const char *);
+NPY_NO_EXPORT  int PyUFunc_SetUsesArraysAsData \
        (void **, size_t);
-NPY_NO_EXPORT void PyUFunc_e_e \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_e_e_As_f_f \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_e_e_As_d_d \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_ee_e \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_ee_e_As_ff_f \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT void PyUFunc_ee_e_As_dd_d \
-       (char **, npy_intp *, npy_intp *, void *);
-NPY_NO_EXPORT int PyUFunc_DefaultTypeResolver \
+NPY_NO_EXPORT  void PyUFunc_e_e \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_e_e_As_f_f \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_e_e_As_d_d \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_ee_e \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_ee_e_As_ff_f \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  void PyUFunc_ee_e_As_dd_d \
+       (char **, npy_intp const *, npy_intp const *, void *);
+NPY_NO_EXPORT  int PyUFunc_DefaultTypeResolver \
        (PyUFuncObject *, NPY_CASTING, PyArrayObject **, PyObject *, PyArray_Descr **);
-NPY_NO_EXPORT int PyUFunc_ValidateCasting \
+NPY_NO_EXPORT  int PyUFunc_ValidateCasting \
        (PyUFuncObject *, NPY_CASTING, PyArrayObject **, PyArray_Descr **);
+NPY_NO_EXPORT  int PyUFunc_RegisterLoopForDescr \
+       (PyUFuncObject *, PyArray_Descr *, PyUFuncGenericFunction, PyArray_Descr **, void *);
+NPY_NO_EXPORT  PyObject * PyUFunc_FromFuncAndDataAndSignatureAndIdentity \
+       (PyUFuncGenericFunction *, void **, char *, int, int, int, int, const char *, const char *, const int, const char *, PyObject *);
 
 #else
 
@@ -112,76 +108,76 @@ static void **PyUFunc_API=NULL;
 
 #define PyUFunc_Type (*(PyTypeObject *)PyUFunc_API[0])
 #define PyUFunc_FromFuncAndData \
-        (*(PyObject * (*)(PyUFuncGenericFunction *, void **, char *, int, int, int, int, char *, char *, int)) \
+        (*(PyObject * (*)(PyUFuncGenericFunction *, void **, char *, int, int, int, int, const char *, const char *, int)) \
          PyUFunc_API[1])
 #define PyUFunc_RegisterLoopForType \
-        (*(int (*)(PyUFuncObject *, int, PyUFuncGenericFunction, int *, void *)) \
+        (*(int (*)(PyUFuncObject *, int, PyUFuncGenericFunction, const int *, void *)) \
          PyUFunc_API[2])
 #define PyUFunc_GenericFunction \
         (*(int (*)(PyUFuncObject *, PyObject *, PyObject *, PyArrayObject **)) \
          PyUFunc_API[3])
 #define PyUFunc_f_f_As_d_d \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[4])
 #define PyUFunc_d_d \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[5])
 #define PyUFunc_f_f \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[6])
 #define PyUFunc_g_g \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[7])
 #define PyUFunc_F_F_As_D_D \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[8])
 #define PyUFunc_F_F \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[9])
 #define PyUFunc_D_D \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[10])
 #define PyUFunc_G_G \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[11])
 #define PyUFunc_O_O \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[12])
 #define PyUFunc_ff_f_As_dd_d \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[13])
 #define PyUFunc_ff_f \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[14])
 #define PyUFunc_dd_d \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[15])
 #define PyUFunc_gg_g \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[16])
 #define PyUFunc_FF_F_As_DD_D \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[17])
 #define PyUFunc_DD_D \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[18])
 #define PyUFunc_FF_F \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[19])
 #define PyUFunc_GG_G \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[20])
 #define PyUFunc_OO_O \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[21])
 #define PyUFunc_O_O_method \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[22])
 #define PyUFunc_OO_O_method \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[23])
 #define PyUFunc_On_Om \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[24])
 #define PyUFunc_GetPyValues \
         (*(int (*)(char *, int *, int *, PyObject **)) \
@@ -199,31 +195,31 @@ static void **PyUFunc_API=NULL;
         (*(int (*)(int, PyObject *, int, int *)) \
          PyUFunc_API[29])
 #define PyUFunc_ReplaceLoopBySignature \
-        (*(int (*)(PyUFuncObject *, PyUFuncGenericFunction, int *, PyUFuncGenericFunction *)) \
+        (*(int (*)(PyUFuncObject *, PyUFuncGenericFunction, const int *, PyUFuncGenericFunction *)) \
          PyUFunc_API[30])
 #define PyUFunc_FromFuncAndDataAndSignature \
-        (*(PyObject * (*)(PyUFuncGenericFunction *, void **, char *, int, int, int, int, char *, char *, int, const char *)) \
+        (*(PyObject * (*)(PyUFuncGenericFunction *, void **, char *, int, int, int, int, const char *, const char *, int, const char *)) \
          PyUFunc_API[31])
 #define PyUFunc_SetUsesArraysAsData \
         (*(int (*)(void **, size_t)) \
          PyUFunc_API[32])
 #define PyUFunc_e_e \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[33])
 #define PyUFunc_e_e_As_f_f \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[34])
 #define PyUFunc_e_e_As_d_d \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[35])
 #define PyUFunc_ee_e \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[36])
 #define PyUFunc_ee_e_As_ff_f \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[37])
 #define PyUFunc_ee_e_As_dd_d \
-        (*(void (*)(char **, npy_intp *, npy_intp *, void *)) \
+        (*(void (*)(char **, npy_intp const *, npy_intp const *, void *)) \
          PyUFunc_API[38])
 #define PyUFunc_DefaultTypeResolver \
         (*(int (*)(PyUFuncObject *, NPY_CASTING, PyArrayObject **, PyObject *, PyArray_Descr **)) \
@@ -231,15 +227,22 @@ static void **PyUFunc_API=NULL;
 #define PyUFunc_ValidateCasting \
         (*(int (*)(PyUFuncObject *, NPY_CASTING, PyArrayObject **, PyArray_Descr **)) \
          PyUFunc_API[40])
+#define PyUFunc_RegisterLoopForDescr \
+        (*(int (*)(PyUFuncObject *, PyArray_Descr *, PyUFuncGenericFunction, PyArray_Descr **, void *)) \
+         PyUFunc_API[41])
+#define PyUFunc_FromFuncAndDataAndSignatureAndIdentity \
+        (*(PyObject * (*)(PyUFuncGenericFunction *, void **, char *, int, int, int, int, const char *, const char *, const int, const char *, PyObject *)) \
+         PyUFunc_API[42])
 
-static int
+static NPY_INLINE int
 _import_umath(void)
 {
-  PyObject *numpy = PyImport_ImportModule("numpy.core.umath");
+  PyObject *numpy = PyImport_ImportModule("numpy.core._multiarray_umath");
   PyObject *c_api = NULL;
 
   if (numpy == NULL) {
-      PyErr_SetString(PyExc_ImportError, "numpy.core.umath failed to import");
+      PyErr_SetString(PyExc_ImportError,
+                      "numpy.core._multiarray_umath failed to import");
       return -1;
   }
   c_api = PyObject_GetAttrString(numpy, "_UFUNC_API");
@@ -249,21 +252,12 @@ _import_umath(void)
       return -1;
   }
 
-#if PY_VERSION_HEX >= 0x03000000
   if (!PyCapsule_CheckExact(c_api)) {
       PyErr_SetString(PyExc_RuntimeError, "_UFUNC_API is not PyCapsule object");
       Py_DECREF(c_api);
       return -1;
   }
   PyUFunc_API = (void **)PyCapsule_GetPointer(c_api, NULL);
-#else
-  if (!PyCObject_Check(c_api)) {
-      PyErr_SetString(PyExc_RuntimeError, "_UFUNC_API is not PyCObject object");
-      Py_DECREF(c_api);
-      return -1;
-  }
-  PyUFunc_API = (void **)PyCObject_AsVoidPtr(c_api);
-#endif
   Py_DECREF(c_api);
   if (PyUFunc_API == NULL) {
       PyErr_SetString(PyExc_RuntimeError, "_UFUNC_API is NULL pointer");
@@ -272,12 +266,6 @@ _import_umath(void)
   return 0;
 }
 
-#if PY_VERSION_HEX >= 0x03000000
-#define NUMPY_IMPORT_UMATH_RETVAL NULL
-#else
-#define NUMPY_IMPORT_UMATH_RETVAL
-#endif
-
 #define import_umath() \
     do {\
         UFUNC_NOFPE\
@@ -285,7 +273,7 @@ _import_umath(void)
             PyErr_Print();\
             PyErr_SetString(PyExc_ImportError,\
                     "numpy.core.umath failed to import");\
-            return NUMPY_IMPORT_UMATH_RETVAL;\
+            return NULL;\
         }\
     } while(0)
 
diff --git a/include/numpy/_numpyconfig.h b/include/numpy/_numpyconfig.h
index d55ffc38d..edb7e3797 100644
--- a/include/numpy/_numpyconfig.h
+++ b/include/numpy/_numpyconfig.h
@@ -1,3 +1,4 @@
+#define NPY_HAVE_ENDIAN_H 1
 #define NPY_SIZEOF_SHORT SIZEOF_SHORT
 #define NPY_SIZEOF_INT SIZEOF_INT
 #define NPY_SIZEOF_LONG SIZEOF_LONG
@@ -8,6 +9,7 @@
 #define NPY_SIZEOF_LONGDOUBLE 16
 #define NPY_SIZEOF_COMPLEX_LONGDOUBLE 32
 #define NPY_SIZEOF_PY_INTPTR_T 8
+#define NPY_SIZEOF_OFF_T 8
 #define NPY_SIZEOF_PY_LONG_LONG 8
 #define NPY_SIZEOF_LONGLONG 8
 #define NPY_NO_SMP 0
@@ -19,10 +21,11 @@
 #define NPY_HAVE_COMPLEX_DOUBLE 1
 #define NPY_HAVE_COMPLEX_FLOAT 1
 #define NPY_HAVE_COMPLEX_LONG_DOUBLE 1
+#define NPY_RELAXED_STRIDES_CHECKING 1
 #define NPY_USE_C99_FORMATS 1
 #define NPY_VISIBILITY_HIDDEN __attribute__((visibility("hidden")))
 #define NPY_ABI_VERSION 0x01000009
-#define NPY_API_VERSION 0x00000007
+#define NPY_API_VERSION 0x0000000D
 
 #ifndef __STDC_FORMAT_MACROS
 #define __STDC_FORMAT_MACROS 1
diff --git a/include/numpy/arrayobject.h b/include/numpy/arrayobject.h
index a84766f63..4f46d6b1a 100644
--- a/include/numpy/arrayobject.h
+++ b/include/numpy/arrayobject.h
@@ -1,14 +1,3 @@
-
-/* This expects the following variables to be defined (besides
-   the usual ones from pyconfig.h
-
-   SIZEOF_LONG_DOUBLE -- sizeof(long double) or sizeof(double) if no
-                         long double is present on platform.
-   CHAR_BIT       --     number of bits in a char (usually 8)
-                         (should be in limits.h)
-
-*/
-
 #ifndef Py_ARRAYOBJECT_H
 #define Py_ARRAYOBJECT_H
 
diff --git a/include/numpy/arrayscalars.h b/include/numpy/arrayscalars.h
index 64450e713..42a0df76a 100644
--- a/include/numpy/arrayscalars.h
+++ b/include/numpy/arrayscalars.h
@@ -135,7 +135,13 @@ typedef struct {
 } PyScalarObject;
 
 #define PyStringScalarObject PyStringObject
-#define PyUnicodeScalarObject PyUnicodeObject
+#define PyStringScalarObject PyStringObject
+typedef struct {
+        /* note that the PyObject_HEAD macro lives right here */
+        PyUnicodeObject base;
+        Py_UCS4 *obval;
+} PyUnicodeScalarObject;
+
 
 typedef struct {
         PyObject_VAR_HEAD
diff --git a/include/numpy/halffloat.h b/include/numpy/halffloat.h
index 944f0ea34..ab0d221fb 100644
--- a/include/numpy/halffloat.h
+++ b/include/numpy/halffloat.h
@@ -37,6 +37,7 @@ int npy_half_signbit(npy_half h);
 npy_half npy_half_copysign(npy_half x, npy_half y);
 npy_half npy_half_spacing(npy_half h);
 npy_half npy_half_nextafter(npy_half x, npy_half y);
+npy_half npy_half_divmod(npy_half x, npy_half y, npy_half *modulus);
 
 /*
  * Half-precision constants
diff --git a/include/numpy/multiarray_api.txt b/include/numpy/multiarray_api.txt
index 7e588f067..3a3268f27 100644
--- a/include/numpy/multiarray_api.txt
+++ b/include/numpy/multiarray_api.txt
@@ -1,6 +1,6 @@
 
 ===========
-Numpy C-API
+NumPy C-API
 ===========
 ::
 
@@ -85,7 +85,7 @@ Get pointer to one of correct type for array
 For backward compatibility
 
 Cast an array using typecode structure.
-steals reference to at --- cannot be NULL
+steals reference to dtype --- cannot be NULL
 
 This function always makes a copy of arr, even if the dtype
 doesn't change.
@@ -144,6 +144,11 @@ new reference -- accepts NULL for mintype
   PyArray_ConvertToCommonType(PyObject *op, int *retn)
 
 
+This function is only used in one place within NumPy and should
+generally be avoided. It is provided mainly for backward compatibility.
+
+The user of the function has to free the returned array.
+
 ::
 
   PyArray_Descr *
@@ -242,18 +247,19 @@ Returns NULL if un-successful.
 ::
 
   PyObject *
-  PyArray_FromDims(int nd, int *d, int type)
+  PyArray_FromDims(int NPY_UNUSED(nd) , int *NPY_UNUSED(d) , int
+                   NPY_UNUSED(type) )
 
-Construct an empty array from dimensions and typenum
+Deprecated, use PyArray_SimpleNew instead.
 
 ::
 
   PyObject *
-  PyArray_FromDimsAndDataAndDescr(int nd, int *d, PyArray_Descr
-                                  *descr, char *data)
+  PyArray_FromDimsAndDataAndDescr(int NPY_UNUSED(nd) , int
+                                  *NPY_UNUSED(d) , PyArray_Descr
+                                  *descr, char *NPY_UNUSED(data) )
 
-Like FromDimsAndData but uses the Descr structure instead of typecode
-as input.
+Deprecated, use PyArray_NewFromDescr instead.
 
 ::
 
@@ -270,7 +276,8 @@ Steals a reference to newtype --- which can be NULL
   PyObject *
   PyArray_EnsureArray(PyObject *op)
 
-This is a quick wrapper around PyArray_FromAny(op, NULL, 0, 0, ENSUREARRAY)
+This is a quick wrapper around
+PyArray_FromAny(op, NULL, 0, 0, NPY_ARRAY_ENSUREARRAY, NULL)
 that special cases Arrays and PyArray_Scalars up front
 It *steals a reference* to the object
 It also guarantees that the result is PyArray_Type
@@ -293,8 +300,8 @@ so it can be used like PyArray_EnsureArray(some_function(...))
 Given a ``FILE *`` pointer ``fp``, and a ``PyArray_Descr``, return an
 array corresponding to the data encoded in that file.
 
-If the dtype is NULL, the default array type is used (double).
-If non-null, the reference is stolen.
+The reference to `dtype` is stolen (it is possible that the passed in
+dtype is not held on to).
 
 The number of elements to read is given as ``num``; if it is < 0, then
 then as many as possible are read.
@@ -356,6 +363,7 @@ steals a reference to dtype (which cannot be NULL)
 
 Return either an array or the appropriate Python object if the array
 is 0d and matches a Python type.
+steals reference to mp
 
 ::
 
@@ -364,6 +372,7 @@ is 0d and matches a Python type.
                    offset)
 
 Get a subset of bytes from each element of the array
+steals reference to typed, must not be NULL
 
 ::
 
@@ -372,6 +381,7 @@ Get a subset of bytes from each element of the array
                    offset, PyObject *val)
 
 Set a subset of bytes from each element of the array
+steals reference to dtype, must not be NULL
 
 ::
 
@@ -383,7 +393,7 @@ Set a subset of bytes from each element of the array
 
   PyObject *
   PyArray_Resize(PyArrayObject *self, PyArray_Dims *newshape, int
-                 refcheck, NPY_ORDER order)
+                 refcheck, NPY_ORDER NPY_UNUSED(order) )
 
 Resize (reallocate data).  Only works if nothing else is referencing this
 array and it is contiguous.  If refcheck is 0, then the reference count is
@@ -486,9 +496,9 @@ Update Several Flags at once.
 ::
 
   PyObject *
-  PyArray_New(PyTypeObject *subtype, int nd, npy_intp *dims, int
-              type_num, npy_intp *strides, void *data, int itemsize, int
-              flags, PyObject *obj)
+  PyArray_New(PyTypeObject *subtype, int nd, npy_intp const *dims, int
+              type_num, npy_intp const *strides, void *data, int
+              itemsize, int flags, PyObject *obj)
 
 Generic new array creation routine.
 
@@ -496,12 +506,13 @@ Generic new array creation routine.
 
   PyObject *
   PyArray_NewFromDescr(PyTypeObject *subtype, PyArray_Descr *descr, int
-                       nd, npy_intp *dims, npy_intp *strides, void
-                       *data, int flags, PyObject *obj)
+                       nd, npy_intp const *dims, npy_intp const
+                       *strides, void *data, int flags, PyObject *obj)
 
 Generic new array creation routine.
 
-steals a reference to descr (even on failure)
+steals a reference to descr. On failure or when dtype->subarray is
+true, dtype will be decrefed.
 
 ::
 
@@ -532,7 +543,7 @@ Get Iterator.
 
 ::
 
-  PyObject *
+  PyObject*
   PyArray_MultiIterNew(int n, ... )
 
 Get MultiIterator,
@@ -572,7 +583,8 @@ Assumes contiguous
 
   npy_bool
   PyArray_CheckStrides(int elsize, int nd, npy_intp numbytes, npy_intp
-                       offset, npy_intp *dims, npy_intp *newstrides)
+                       offset, npy_intp const *dims, npy_intp const
+                       *newstrides)
 
 
 ::
@@ -686,7 +698,8 @@ TODO: For NumPy 2.0, add a NPY_CASTING parameter.
 ::
 
   int
-  PyArray_CompareUCS4(npy_ucs4 *s1, npy_ucs4 *s2, size_t len)
+  PyArray_CompareUCS4(npy_ucs4 const *s1, npy_ucs4 const *s2, size_t
+                      len)
 
 
 ::
@@ -712,6 +725,10 @@ don't use with PyArray_ITER_GOTO1D because factors are not adjusted
   void
   PyArray_Item_INCREF(char *data, PyArray_Descr *descr)
 
+XINCREF all objects in a single array item. This is complicated for
+structured datatypes where the position of objects needs to be extracted.
+The function is execute recursively for each nested field or subarrays dtype
+such as as `np.dtype([("field1", "O"), ("field2", "f,O", (3,2))])`
 
 ::
 
@@ -719,6 +736,11 @@ don't use with PyArray_ITER_GOTO1D because factors are not adjusted
   PyArray_Item_XDECREF(char *data, PyArray_Descr *descr)
 
 
+XDECREF all objects in a single array item. This is complicated for
+structured datatypes where the position of objects needs to be extracted.
+The function is execute recursively for each nested field or subarrays dtype
+such as as `np.dtype([("field1", "O"), ("field2", "f,O", (3,2))])`
+
 ::
 
   PyObject *
@@ -1029,28 +1051,28 @@ Returns a contiguous array
 ::
 
   npy_intp
-  PyArray_MultiplyList(npy_intp *l1, int n)
+  PyArray_MultiplyList(npy_intp const *l1, int n)
 
 Multiply a List
 
 ::
 
   int
-  PyArray_MultiplyIntList(int *l1, int n)
+  PyArray_MultiplyIntList(int const *l1, int n)
 
 Multiply a List of ints
 
 ::
 
   void *
-  PyArray_GetPtr(PyArrayObject *obj, npy_intp*ind)
+  PyArray_GetPtr(PyArrayObject *obj, npy_intp const*ind)
 
 Produce a pointer into array
 
 ::
 
   int
-  PyArray_CompareLists(npy_intp *l1, npy_intp *l2, int n)
+  PyArray_CompareLists(npy_intp const *l1, npy_intp const *l2, int n)
 
 Compare Lists
 
@@ -1066,15 +1088,17 @@ steals a reference to typedescr -- can be NULL
 ::
 
   int
-  PyArray_As1D(PyObject **op, char **ptr, int *d1, int typecode)
+  PyArray_As1D(PyObject **NPY_UNUSED(op) , char **NPY_UNUSED(ptr) , int
+               *NPY_UNUSED(d1) , int NPY_UNUSED(typecode) )
 
 Convert to a 1D C-array
 
 ::
 
   int
-  PyArray_As2D(PyObject **op, char ***ptr, int *d1, int *d2, int
-               typecode)
+  PyArray_As2D(PyObject **NPY_UNUSED(op) , char ***NPY_UNUSED(ptr) , int
+               *NPY_UNUSED(d1) , int *NPY_UNUSED(d2) , int
+               NPY_UNUSED(typecode) )
 
 Convert to a 2D C-array
 
@@ -1106,7 +1130,7 @@ as you get a new reference to it.
   PyArray_IntpFromSequence(PyObject *seq, npy_intp *vals, int maxvals)
 
 PyArray_IntpFromSequence
-Returns the number of dimensions or -1 if an error occurred.
+Returns the number of integers converted or -1 if an error occurred.
 vals must be large enough to hold maxvals
 
 ::
@@ -1258,24 +1282,25 @@ equivalent (same basic kind and same itemsize).
 ::
 
   PyObject *
-  PyArray_Zeros(int nd, npy_intp *dims, PyArray_Descr *type, int
+  PyArray_Zeros(int nd, npy_intp const *dims, PyArray_Descr *type, int
                 is_f_order)
 
 Zeros
 
-steal a reference
+steals a reference to type. On failure or when dtype->subarray is
+true, dtype will be decrefed.
 accepts NULL type
 
 ::
 
   PyObject *
-  PyArray_Empty(int nd, npy_intp *dims, PyArray_Descr *type, int
+  PyArray_Empty(int nd, npy_intp const *dims, PyArray_Descr *type, int
                 is_f_order)
 
 Empty
 
 accepts NULL type
-steals referenct to type
+steals a reference to type
 
 ::
 
@@ -1370,14 +1395,14 @@ Initialize arrfuncs to NULL
 ::
 
   PyObject *
-  PyArray_IntTupleFromIntp(int len, npy_intp *vals)
+  PyArray_IntTupleFromIntp(int len, npy_intp const *vals)
 
 PyArray_IntTupleFromIntp
 
 ::
 
   int
-  PyArray_TypeNumFromName(char *str)
+  PyArray_TypeNumFromName(char const *str)
 
 
 ::
@@ -1459,24 +1484,24 @@ convert 0-d arrays to 1-d arrays
 ::
 
   npy_intp
-  PyArray_OverflowMultiplyList(npy_intp *l1, int n)
+  PyArray_OverflowMultiplyList(npy_intp const *l1, int n)
 
 Multiply a List of Non-negative numbers with over-flow detection.
 
 ::
 
   int
-  PyArray_CompareString(char *s1, char *s2, size_t len)
+  PyArray_CompareString(const char *s1, const char *s2, size_t len)
 
 
 ::
 
-  PyObject *
+  PyObject*
   PyArray_MultiIterFromObjects(PyObject **mps, int n, int nadd, ... )
 
 Get MultiIterator from array of Python objects and any additional
 
-PyObject **mps -- array of PyObjects
+PyObject **mps - array of PyObjects
 int n - number of PyObjects in the array
 int nadd - number of additional arrays to include in the iterator.
 
@@ -1508,7 +1533,7 @@ correlate(a2, a1), and conjugate the second argument for complex inputs
 ::
 
   PyObject*
-  PyArray_NeighborhoodIterNew(PyArrayIterObject *x, npy_intp
+  PyArray_NeighborhoodIterNew(PyArrayIterObject *x, const npy_intp
                               *bounds, int mode, PyArrayObject*fill)
 
 A Neighborhood Iterator object.
@@ -1516,7 +1541,7 @@ A Neighborhood Iterator object.
 ::
 
   void
-  PyArray_SetDatetimeParseFunction(PyObject *op)
+  PyArray_SetDatetimeParseFunction(PyObject *NPY_UNUSED(op) )
 
 This function is scheduled to be removed
 
@@ -1525,8 +1550,9 @@ TO BE REMOVED - NOT USED INTERNALLY.
 ::
 
   void
-  PyArray_DatetimeToDatetimeStruct(npy_datetime val, NPY_DATETIMEUNIT
-                                   fr, npy_datetimestruct *result)
+  PyArray_DatetimeToDatetimeStruct(npy_datetime NPY_UNUSED(val)
+                                   , NPY_DATETIMEUNIT NPY_UNUSED(fr)
+                                   , npy_datetimestruct *result)
 
 Fill the datetime struct from the value and resolution unit.
 
@@ -1535,8 +1561,9 @@ TO BE REMOVED - NOT USED INTERNALLY.
 ::
 
   void
-  PyArray_TimedeltaToTimedeltaStruct(npy_timedelta val, NPY_DATETIMEUNIT
-                                     fr, npy_timedeltastruct *result)
+  PyArray_TimedeltaToTimedeltaStruct(npy_timedelta NPY_UNUSED(val)
+                                     , NPY_DATETIMEUNIT NPY_UNUSED(fr)
+                                     , npy_timedeltastruct *result)
 
 Fill the timedelta struct from the timedelta value and resolution unit.
 
@@ -1545,8 +1572,8 @@ TO BE REMOVED - NOT USED INTERNALLY.
 ::
 
   npy_datetime
-  PyArray_DatetimeStructToDatetime(NPY_DATETIMEUNIT
-                                   fr, npy_datetimestruct *d)
+  PyArray_DatetimeStructToDatetime(NPY_DATETIMEUNIT NPY_UNUSED(fr)
+                                   , npy_datetimestruct *NPY_UNUSED(d) )
 
 Create a datetime value from a filled datetime struct and resolution unit.
 
@@ -1555,8 +1582,9 @@ TO BE REMOVED - NOT USED INTERNALLY.
 ::
 
   npy_datetime
-  PyArray_TimedeltaStructToTimedelta(NPY_DATETIMEUNIT
-                                     fr, npy_timedeltastruct *d)
+  PyArray_TimedeltaStructToTimedelta(NPY_DATETIMEUNIT NPY_UNUSED(fr)
+                                     , npy_timedeltastruct
+                                     *NPY_UNUSED(d) )
 
 Create a timdelta value from a filled timedelta struct and resolution unit.
 
@@ -1784,7 +1812,7 @@ the GIL.
 ::
 
   int
-  NpyIter_GotoMultiIndex(NpyIter *iter, npy_intp *multi_index)
+  NpyIter_GotoMultiIndex(NpyIter *iter, npy_intp const *multi_index)
 
 Sets the iterator to the specified multi-index, which must have the
 correct number of entries for 'ndim'.  It is only valid
@@ -2135,7 +2163,8 @@ dtype     - If not NULL, overrides the data type of the result.
 subok     - If 1, use the prototype's array subtype, otherwise
 always create a base-class array.
 
-NOTE: If dtype is not NULL, steals the dtype reference.
+NOTE: If dtype is not NULL, steals the dtype reference.  On failure or when
+dtype->subarray is true, dtype will be decrefed.
 
 ::
 
@@ -2147,60 +2176,6 @@ NOTE: If dtype is not NULL, steals the dtype reference.
                                    *out_dims, PyArrayObject
                                    **out_arr, PyObject *context)
 
-Retrieves the array parameters for viewing/converting an arbitrary
-PyObject* to a NumPy array. This allows the "innate type and shape"
-of Python list-of-lists to be discovered without
-actually converting to an array.
-
-In some cases, such as structured arrays and the __array__ interface,
-a data type needs to be used to make sense of the object.  When
-this is needed, provide a Descr for 'requested_dtype', otherwise
-provide NULL. This reference is not stolen. Also, if the requested
-dtype doesn't modify the interpretation of the input, out_dtype will
-still get the "innate" dtype of the object, not the dtype passed
-in 'requested_dtype'.
-
-If writing to the value in 'op' is desired, set the boolean
-'writeable' to 1.  This raises an error when 'op' is a scalar, list
-of lists, or other non-writeable 'op'.
-
-Result: When success (0 return value) is returned, either out_arr
-is filled with a non-NULL PyArrayObject and
-the rest of the parameters are untouched, or out_arr is
-filled with NULL, and the rest of the parameters are
-filled.
-
-Typical usage:
-
-PyArrayObject *arr = NULL;
-PyArray_Descr *dtype = NULL;
-int ndim = 0;
-npy_intp dims[NPY_MAXDIMS];
-
-if (PyArray_GetArrayParamsFromObject(op, NULL, 1, &dtype,
-&ndim, &dims, &arr, NULL) < 0) {
-return NULL;
-}
-if (arr == NULL) {
-... validate/change dtype, validate flags, ndim, etc ...
-// Could make custom strides here too
-arr = PyArray_NewFromDescr(&PyArray_Type, dtype, ndim,
-dims, NULL,
-is_f_order ? NPY_ARRAY_F_CONTIGUOUS : 0,
-NULL);
-if (arr == NULL) {
-return NULL;
-}
-if (PyArray_CopyObject(arr, op) < 0) {
-Py_DECREF(arr);
-return NULL;
-}
-}
-else {
-... in this case the other parameters weren't filled, just
-validate and possibly copy arr itself ...
-}
-... use arr ...
 
 ::
 
@@ -2218,7 +2193,7 @@ could be applied to each axis, like in ravel_multi_index.
   PyArray_MatrixProduct2(PyObject *op1, PyObject
                          *op2, PyArrayObject*out)
 
-Numeric.matrixproduct(a,v,out)
+Numeric.matrixproduct2(a,v,out)
 just like inner product but does the swapaxes stuff on the fly
 
 ::
@@ -2260,7 +2235,7 @@ Returns 0 on success, -1 on failure.
 ::
 
   void
-  PyArray_CreateSortedStridePerm(int ndim, npy_intp
+  PyArray_CreateSortedStridePerm(int ndim, npy_intp const
                                  *strides, npy_stride_sort_item
                                  *out_strideperm)
 
@@ -2273,7 +2248,7 @@ For example, the stride array (4, -2, 12) becomes
 ::
 
   void
-  PyArray_RemoveAxesInPlace(PyArrayObject *arr, npy_bool *flags)
+  PyArray_RemoveAxesInPlace(PyArrayObject *arr, const npy_bool *flags)
 
 
 Removes the axes flagged as True from the array,
@@ -2284,6 +2259,10 @@ index zero for that axis.
 WARNING: If an axis flagged for removal has a shape equal to zero,
 the array will point to invalid memory. The caller must
 validate this!
+If an axis flagged for removal has a shape larger than one,
+the aligned flag (and in the future the contiguous flags),
+may need explicit update.
+(check also NPY_RELAXED_STRIDES_CHECKING)
 
 For example, this can be used to remove the reduction axes
 from a reduction result once its computation is complete.
@@ -2321,7 +2300,7 @@ just "array".
 Precondition: 'arr' is a copy of 'base' (though possibly with different
 strides, ordering, etc.). This function sets the UPDATEIFCOPY flag and the
 ->base pointer on 'arr', so that when 'arr' is destructed, it will copy any
-changes back to 'base'.
+changes back to 'base'. DEPRECATED, use PyArray_SetWritebackIfCopyBase
 
 Steals a reference to 'base'.
 
@@ -2370,6 +2349,111 @@ result = PyDataMem_RENEW(ptr, size) -> (*hook)(ptr, result, size, user_data)
 When the hook is called, the GIL will be held by the calling
 thread.  The hook should be written to be reentrant, if it performs
 operations that might cause new allocation events (such as the
-creation/descruction numpy objects, or creating/destroying Python
+creation/destruction numpy objects, or creating/destroying Python
 objects which might cause a gc)
 
+::
+
+  void
+  PyArray_MapIterSwapAxes(PyArrayMapIterObject *mit, PyArrayObject
+                          **ret, int getmap)
+
+
+::
+
+  PyObject *
+  PyArray_MapIterArray(PyArrayObject *a, PyObject *index)
+
+
+Use advanced indexing to iterate an array.
+
+::
+
+  void
+  PyArray_MapIterNext(PyArrayMapIterObject *mit)
+
+This function needs to update the state of the map iterator
+and point mit->dataptr to the memory-location of the next object
+
+Note that this function never handles an extra operand but provides
+compatibility for an old (exposed) API.
+
+::
+
+  int
+  PyArray_Partition(PyArrayObject *op, PyArrayObject *ktharray, int
+                    axis, NPY_SELECTKIND which)
+
+Partition an array in-place
+
+::
+
+  PyObject *
+  PyArray_ArgPartition(PyArrayObject *op, PyArrayObject *ktharray, int
+                       axis, NPY_SELECTKIND which)
+
+ArgPartition an array
+
+::
+
+  int
+  PyArray_SelectkindConverter(PyObject *obj, NPY_SELECTKIND *selectkind)
+
+Convert object to select kind
+
+::
+
+  void *
+  PyDataMem_NEW_ZEROED(size_t size, size_t elsize)
+
+Allocates zeroed memory for array data.
+
+::
+
+  int
+  PyArray_CheckAnyScalarExact(PyObject *obj)
+
+return true an object is exactly a numpy scalar
+
+::
+
+  PyObject *
+  PyArray_MapIterArrayCopyIfOverlap(PyArrayObject *a, PyObject
+                                    *index, int
+                                    copy_if_overlap, PyArrayObject
+                                    *extra_op)
+
+
+Same as PyArray_MapIterArray, but:
+
+If copy_if_overlap != 0, check if `a` has memory overlap with any of the
+arrays in `index` and with `extra_op`. If yes, make copies as appropriate
+to avoid problems if `a` is modified during the iteration.
+`iter->array` may contain a copied array (UPDATEIFCOPY/WRITEBACKIFCOPY set).
+
+::
+
+  int
+  PyArray_ResolveWritebackIfCopy(PyArrayObject *self)
+
+
+If WRITEBACKIFCOPY and self has data, reset the base WRITEABLE flag,
+copy the local data to base, release the local data, and set flags
+appropriately. Return 0 if not relevant, 1 if success, < 0 on failure
+
+::
+
+  int
+  PyArray_SetWritebackIfCopyBase(PyArrayObject *arr, PyArrayObject
+                                 *base)
+
+
+Precondition: 'arr' is a copy of 'base' (though possibly with different
+strides, ordering, etc.). This function sets the WRITEBACKIFCOPY flag and the
+->base pointer on 'arr', call PyArray_ResolveWritebackIfCopy to copy any
+changes back to 'base' before deallocating the array.
+
+Steals a reference to 'base'.
+
+Returns 0 on success, -1 on failure.
+
diff --git a/include/numpy/ndarrayobject.h b/include/numpy/ndarrayobject.h
index f00dd7744..5ef1f10aa 100644
--- a/include/numpy/ndarrayobject.h
+++ b/include/numpy/ndarrayobject.h
@@ -5,15 +5,10 @@
 #ifndef NPY_NDARRAYOBJECT_H
 #define NPY_NDARRAYOBJECT_H
 #ifdef __cplusplus
-#define CONFUSE_EMACS {
-#define CONFUSE_EMACS2 }
-extern "C" CONFUSE_EMACS
-#undef CONFUSE_EMACS
-#undef CONFUSE_EMACS2
-/* ... otherwise a semi-smart identer (like emacs) tries to indent
-       everything when you're typing */
+extern "C" {
 #endif
 
+#include <Python.h>
 #include "ndarraytypes.h"
 
 /* Includes the "function" C-API -- these are all stored in a
@@ -26,9 +21,9 @@ extern "C" CONFUSE_EMACS
 #include "__multiarray_api.h"
 
 
-/* C-API that requries previous API to be defined */
+/* C-API that requires previous API to be defined */
 
-#define PyArray_DescrCheck(op) (((PyObject*)(op))->ob_type==&PyArrayDescr_Type)
+#define PyArray_DescrCheck(op) PyObject_TypeCheck(op, &PyArrayDescr_Type)
 
 #define PyArray_Check(op) PyObject_TypeCheck(op, &PyArray_Type)
 #define PyArray_CheckExact(op) (((PyObject*)(op))->ob_type == &PyArray_Type)
@@ -50,13 +45,13 @@ extern "C" CONFUSE_EMACS
 
 #define PyArray_CheckScalar(m) (PyArray_IsScalar(m, Generic) ||               \
                                 PyArray_IsZeroDim(m))
-
 #define PyArray_IsPythonNumber(obj)                                           \
-        (PyInt_Check(obj) || PyFloat_Check(obj) || PyComplex_Check(obj) ||    \
+        (PyFloat_Check(obj) || PyComplex_Check(obj) ||                        \
          PyLong_Check(obj) || PyBool_Check(obj))
-
+#define PyArray_IsIntegerScalar(obj) (PyLong_Check(obj)                       \
+              || PyArray_IsScalar((obj), Integer))
 #define PyArray_IsPythonScalar(obj)                                           \
-        (PyArray_IsPythonNumber(obj) || PyString_Check(obj) ||                \
+        (PyArray_IsPythonNumber(obj) || PyBytes_Check(obj) ||                 \
          PyUnicode_Check(obj))
 
 #define PyArray_IsAnyScalar(obj)                                              \
@@ -65,10 +60,6 @@ extern "C" CONFUSE_EMACS
 #define PyArray_CheckAnyScalar(obj) (PyArray_IsPythonScalar(obj) ||           \
                                      PyArray_CheckScalar(obj))
 
-#define PyArray_IsIntegerScalar(obj) (PyInt_Check(obj)                        \
-              || PyLong_Check(obj)                                            \
-              || PyArray_IsScalar((obj), Integer))
-
 
 #define PyArray_GETCONTIGUOUS(m) (PyArray_ISCONTIGUOUS(m) ?                   \
                                   Py_INCREF(m), (m) :                         \
@@ -87,7 +78,7 @@ extern "C" CONFUSE_EMACS
                                                       NULL)
 
 #define PyArray_FROM_OT(m,type) PyArray_FromAny(m,                            \
-                                PyArray_DescrFromType(type), 0, 0, 0, NULL);
+                                PyArray_DescrFromType(type), 0, 0, 0, NULL)
 
 #define PyArray_FROM_OTF(m, type, flags) \
         PyArray_FromAny(m, PyArray_DescrFromType(type), 0, 0, \
@@ -107,9 +98,10 @@ extern "C" CONFUSE_EMACS
 
 #define PyArray_FILLWBYTE(obj, val) memset(PyArray_DATA(obj), val, \
                                            PyArray_NBYTES(obj))
-
+#ifndef PYPY_VERSION
 #define PyArray_REFCOUNT(obj) (((PyObject *)(obj))->ob_refcnt)
 #define NPY_REFCOUNT PyArray_REFCOUNT
+#endif
 #define NPY_MAX_ELSIZE (2 * NPY_SIZEOF_LONGDOUBLE)
 
 #define PyArray_ContiguousFromAny(op, type, min_depth, max_depth) \
@@ -160,16 +152,20 @@ extern "C" CONFUSE_EMACS
                                             (k)*PyArray_STRIDES(obj)[2] + \
                                             (l)*PyArray_STRIDES(obj)[3]))
 
+/* Move to arrayobject.c once PyArray_XDECREF_ERR is removed */
 static NPY_INLINE void
-PyArray_XDECREF_ERR(PyArrayObject *arr)
+PyArray_DiscardWritebackIfCopy(PyArrayObject *arr)
 {
-    if (arr != NULL) {
-        if (PyArray_FLAGS(arr) & NPY_ARRAY_UPDATEIFCOPY) {
-            PyArrayObject *base = (PyArrayObject *)PyArray_BASE(arr);
-            PyArray_ENABLEFLAGS(base, NPY_ARRAY_WRITEABLE);
+    PyArrayObject_fields *fa = (PyArrayObject_fields *)arr;
+    if (fa && fa->base) {
+        if ((fa->flags & NPY_ARRAY_UPDATEIFCOPY) ||
+                (fa->flags & NPY_ARRAY_WRITEBACKIFCOPY)) {
+            PyArray_ENABLEFLAGS((PyArrayObject*)fa->base, NPY_ARRAY_WRITEABLE);
+            Py_DECREF(fa->base);
+            fa->base = NULL;
+            PyArray_CLEARFLAGS(arr, NPY_ARRAY_WRITEBACKIFCOPY);
             PyArray_CLEARFLAGS(arr, NPY_ARRAY_UPDATEIFCOPY);
         }
-        Py_DECREF(arr);
     }
 }
 
@@ -218,21 +214,49 @@ PyArray_XDECREF_ERR(PyArrayObject *arr)
 /*
    Check to see if this key in the dictionary is the "title"
    entry of the tuple (i.e. a duplicate dictionary entry in the fields
-   dict.
+   dict).
 */
 
-#define NPY_TITLE_KEY(key, value) ((PyTuple_GET_SIZE((value))==3) && \
-                                   (PyTuple_GET_ITEM((value), 2) == (key)))
-
+static NPY_INLINE int
+NPY_TITLE_KEY_check(PyObject *key, PyObject *value)
+{
+    PyObject *title;
+    if (PyTuple_Size(value) != 3) {
+        return 0;
+    }
+    title = PyTuple_GetItem(value, 2);
+    if (key == title) {
+        return 1;
+    }
+#ifdef PYPY_VERSION
+    /*
+     * On PyPy, dictionary keys do not always preserve object identity.
+     * Fall back to comparison by value.
+     */
+    if (PyUnicode_Check(title) && PyUnicode_Check(key)) {
+        return PyUnicode_Compare(title, key) == 0 ? 1 : 0;
+    }
+#endif
+    return 0;
+}
 
-/* Define python version independent deprecation macro */
+/* Macro, for backward compat with "if NPY_TITLE_KEY(key, value) { ..." */
+#define NPY_TITLE_KEY(key, value) (NPY_TITLE_KEY_check((key), (value)))
 
-#if PY_VERSION_HEX >= 0x02050000
 #define DEPRECATE(msg) PyErr_WarnEx(PyExc_DeprecationWarning,msg,1)
 #define DEPRECATE_FUTUREWARNING(msg) PyErr_WarnEx(PyExc_FutureWarning,msg,1)
-#else
-#define DEPRECATE(msg) PyErr_Warn(PyExc_DeprecationWarning,msg)
-#define DEPRECATE_FUTUREWARNING(msg) PyErr_Warn(PyExc_FutureWarning,msg)
+
+#if !defined(NPY_NO_DEPRECATED_API) || \
+    (NPY_NO_DEPRECATED_API < NPY_1_14_API_VERSION)
+static NPY_INLINE void
+PyArray_XDECREF_ERR(PyArrayObject *arr)
+{
+    /* 2017-Nov-10 1.14 */
+    DEPRECATE("PyArray_XDECREF_ERR is deprecated, call "
+        "PyArray_DiscardWritebackIfCopy then Py_XDECREF instead");
+    PyArray_DiscardWritebackIfCopy(arr);
+    Py_XDECREF(arr);
+}
 #endif
 
 
diff --git a/include/numpy/ndarraytypes.h b/include/numpy/ndarraytypes.h
index 04d037ec8..5b7e8952e 100644
--- a/include/numpy/ndarraytypes.h
+++ b/include/numpy/ndarraytypes.h
@@ -1,19 +1,12 @@
 #ifndef NDARRAYTYPES_H
 #define NDARRAYTYPES_H
 
-/* numpyconfig.h is auto-generated by the installer */
-#include "numpyconfig.h"
-
 #include "npy_common.h"
 #include "npy_endian.h"
 #include "npy_cpu.h"
 #include "utils.h"
 
-#ifdef NPY_ENABLE_SEPARATE_COMPILATION
-        #define NPY_NO_EXPORT NPY_VISIBILITY_HIDDEN
-#else
-        #define NPY_NO_EXPORT static
-#endif
+#define NPY_NO_EXPORT NPY_VISIBILITY_HIDDEN
 
 /* Only use thread if configured in config and python supports it */
 #if defined WITH_THREAD && !NPY_NO_SMP
@@ -22,7 +15,17 @@
         #define NPY_ALLOW_THREADS 0
 #endif
 
+#ifndef __has_extension
+#define __has_extension(x) 0
+#endif
 
+#if !defined(_NPY_NO_DEPRECATIONS) && \
+    ((defined(__GNUC__)&& __GNUC__ >= 6) || \
+     __has_extension(attribute_deprecated_with_message))
+#define NPY_ATTR_DEPRECATE(text) __attribute__ ((deprecated (text)))
+#else
+#define NPY_ATTR_DEPRECATE(text)
+#endif
 
 /*
  * There are several places in the code where an array of dimensions
@@ -78,12 +81,15 @@ enum NPY_TYPES {    NPY_BOOL=0,
 
                     NPY_NTYPES,
                     NPY_NOTYPE,
-                    NPY_CHAR,      /* special flag */
+                    NPY_CHAR NPY_ATTR_DEPRECATE("Use NPY_STRING"),
                     NPY_USERDEF=256,  /* leave room for characters */
 
                     /* The number of types not including the new 1.6 types */
                     NPY_NTYPES_ABI_COMPATIBLE=21
 };
+#ifdef _MSC_VER
+#pragma deprecated(NPY_CHAR)
+#endif
 
 /* basetype array priority */
 #define NPY_PRIORITY 0.0
@@ -150,12 +156,26 @@ enum NPY_TYPECHAR {
         NPY_COMPLEXLTR = 'c'
 };
 
+/*
+ * Changing this may break Numpy API compatibility
+ * due to changing offsets in PyArray_ArrFuncs, so be
+ * careful. Here we have reused the mergesort slot for
+ * any kind of stable sort, the actual implementation will
+ * depend on the data type.
+ */
 typedef enum {
         NPY_QUICKSORT=0,
         NPY_HEAPSORT=1,
-        NPY_MERGESORT=2
+        NPY_MERGESORT=2,
+        NPY_STABLESORT=2,
 } NPY_SORTKIND;
-#define NPY_NSORTS (NPY_MERGESORT + 1)
+#define NPY_NSORTS (NPY_STABLESORT + 1)
+
+
+typedef enum {
+        NPY_INTROSELECT=0
+} NPY_SELECTKIND;
+#define NPY_NSELECTS (NPY_INTROSELECT + 1)
 
 
 typedef enum {
@@ -199,13 +219,7 @@ typedef enum {
         /* Allow safe casts or casts within the same kind */
         NPY_SAME_KIND_CASTING=3,
         /* Allow any casts */
-        NPY_UNSAFE_CASTING=4,
-
-        /*
-         * Temporary internal definition only, will be removed in upcoming
-         * release, see below
-         * */
-        NPY_INTERNAL_UNSAFE_CASTING_BUT_WARN_UNLESS_SAME_KIND = 100,
+        NPY_UNSAFE_CASTING=4
 } NPY_CASTING;
 
 typedef enum {
@@ -229,29 +243,34 @@ typedef enum {
  *   TIMEZONE: 5
  *   NULL TERMINATOR: 1
  */
-#define NPY_DATETIME_MAX_ISO8601_STRLEN (21+3*5+1+3*6+6+1)
+#define NPY_DATETIME_MAX_ISO8601_STRLEN (21 + 3*5 + 1 + 3*6 + 6 + 1)
 
+/* The FR in the unit names stands for frequency */
 typedef enum {
-        NPY_FR_Y = 0,  /* Years */
-        NPY_FR_M = 1,  /* Months */
-        NPY_FR_W = 2,  /* Weeks */
+        /* Force signed enum type, must be -1 for code compatibility */
+        NPY_FR_ERROR = -1,      /* error or undetermined */
+
+        /* Start of valid units */
+        NPY_FR_Y = 0,           /* Years */
+        NPY_FR_M = 1,           /* Months */
+        NPY_FR_W = 2,           /* Weeks */
         /* Gap where 1.6 NPY_FR_B (value 3) was */
-        NPY_FR_D = 4,  /* Days */
-        NPY_FR_h = 5,  /* hours */
-        NPY_FR_m = 6,  /* minutes */
-        NPY_FR_s = 7,  /* seconds */
-        NPY_FR_ms = 8, /* milliseconds */
-        NPY_FR_us = 9, /* microseconds */
-        NPY_FR_ns = 10,/* nanoseconds */
-        NPY_FR_ps = 11,/* picoseconds */
-        NPY_FR_fs = 12,/* femtoseconds */
-        NPY_FR_as = 13,/* attoseconds */
-        NPY_FR_GENERIC = 14 /* Generic, unbound units, can convert to anything */
+        NPY_FR_D = 4,           /* Days */
+        NPY_FR_h = 5,           /* hours */
+        NPY_FR_m = 6,           /* minutes */
+        NPY_FR_s = 7,           /* seconds */
+        NPY_FR_ms = 8,          /* milliseconds */
+        NPY_FR_us = 9,          /* microseconds */
+        NPY_FR_ns = 10,         /* nanoseconds */
+        NPY_FR_ps = 11,         /* picoseconds */
+        NPY_FR_fs = 12,         /* femtoseconds */
+        NPY_FR_as = 13,         /* attoseconds */
+        NPY_FR_GENERIC = 14     /* unbound units, can convert to anything */
 } NPY_DATETIMEUNIT;
 
 /*
  * NOTE: With the NPY_FR_B gap for 1.6 ABI compatibility, NPY_DATETIME_NUMUNITS
- *       is technically one more than the actual number of units.
+ * is technically one more than the actual number of units.
  */
 #define NPY_DATETIME_NUMUNITS (NPY_FR_GENERIC + 1)
 #define NPY_DATETIME_DEFAULTUNIT NPY_FR_GENERIC
@@ -334,10 +353,12 @@ struct NpyAuxData_tag {
 
 #define NPY_USE_PYMEM 1
 
+
 #if NPY_USE_PYMEM == 1
-#define PyArray_malloc PyMem_Malloc
-#define PyArray_free PyMem_Free
-#define PyArray_realloc PyMem_Realloc
+/* use the Raw versions which are safe to call with the GIL released */
+#define PyArray_malloc PyMem_RawMalloc
+#define PyArray_free PyMem_RawFree
+#define PyArray_realloc PyMem_RawRealloc
 #else
 #define PyArray_malloc malloc
 #define PyArray_free free
@@ -394,6 +415,12 @@ typedef int (PyArray_FillFunc)(void *, npy_intp, void *);
 
 typedef int (PyArray_SortFunc)(void *, npy_intp, void *);
 typedef int (PyArray_ArgSortFunc)(void *, npy_intp *, npy_intp, void *);
+typedef int (PyArray_PartitionFunc)(void *, npy_intp, npy_intp,
+                                    npy_intp *, npy_intp *,
+                                    void *);
+typedef int (PyArray_ArgPartitionFunc)(void *, npy_intp *, npy_intp, npy_intp,
+                                       npy_intp *, npy_intp *,
+                                       void *);
 
 typedef int (PyArray_FillWithScalarFunc)(void *, npy_intp, void *, void *);
 
@@ -477,7 +504,8 @@ typedef struct {
         PyArray_NonzeroFunc *nonzero;
 
         /*
-         * Used for arange.
+         * Used for arange. Should return 0 on success
+         * and -1 on failure.
          * Can be NULL.
          */
         PyArray_FillFunc *fill;
@@ -616,6 +644,10 @@ typedef struct _PyArray_Descr {
          * for NumPy 1.7.0.
          */
         NpyAuxData *c_metadata;
+        /* Cached hash value (-1 if not yet computed).
+         * This was added for NumPy 2.0.0.
+         */
+        npy_hash_t hash;
 } PyArray_Descr;
 
 typedef struct _arr_descr {
@@ -630,8 +662,8 @@ typedef struct _arr_descr {
  * (PyArray_DATA and friends) to access fields here for a number of
  * releases. Direct access to the members themselves is deprecated.
  * To ensure that your code does not use deprecated access,
- * #define NPY_NO_DEPRECATED_API NPY_1_7_VERSION
- * (or NPY_1_8_VERSION or higher as required).
+ * #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
+ * (or NPY_1_8_API_VERSION or higher as required).
  */
 /* This struct will be moved to a private header in a future release */
 typedef struct tagPyArrayObject_fields {
@@ -650,7 +682,7 @@ typedef struct tagPyArrayObject_fields {
     /*
      * This object is decref'd upon
      * deletion of array. Except in the
-     * case of UPDATEIFCOPY which has
+     * case of WRITEBACKIFCOPY which has
      * special handling.
      *
      * For views it points to the original
@@ -658,12 +690,12 @@ typedef struct tagPyArrayObject_fields {
      * views occur.
      *
      * For creation from buffer object it
-     * points to an object that shold be
+     * points to an object that should be
      * decref'd on deletion
      *
-     * For UPDATEIFCOPY flag this is an
-     * array to-be-updated upon deletion
-     * of this one
+     * For WRITEBACKIFCOPY flag this is an
+     * array to-be-updated upon calling
+     * PyArray_ResolveWritebackIfCopy
      */
     PyObject *base;
     /* Pointer to type structure */
@@ -678,7 +710,8 @@ typedef struct tagPyArrayObject_fields {
  * To hide the implementation details, we only expose
  * the Python struct HEAD.
  */
-#if !(defined(NPY_NO_DEPRECATED_API) && (NPY_API_VERSION <= NPY_NO_DEPRECATED_API))
+#if !defined(NPY_NO_DEPRECATED_API) || \
+    (NPY_NO_DEPRECATED_API < NPY_1_7_API_VERSION)
 /*
  * Can't put this in npy_deprecated_api.h like the others.
  * PyArrayObject field access is deprecated as of NumPy 1.7.
@@ -757,7 +790,14 @@ typedef int (PyArray_FinalizeFunc)(PyArrayObject *, PyObject *);
 
 /*
  * Note: all 0-d arrays are C_CONTIGUOUS and F_CONTIGUOUS. If a
- * 1-d array is C_CONTIGUOUS it is also F_CONTIGUOUS
+ * 1-d array is C_CONTIGUOUS it is also F_CONTIGUOUS. Arrays with
+ * more then one dimension can be C_CONTIGUOUS and F_CONTIGUOUS
+ * at the same time if they have either zero or one element.
+ * If NPY_RELAXED_STRIDES_CHECKING is set, a higher dimensional
+ * array is always C_CONTIGUOUS and F_CONTIGUOUS if it has zero elements
+ * and the array is contiguous if ndarray.squeeze() is contiguous.
+ * I.e. dimensions for which `ndarray.shape[dimension] == 1` are
+ * ignored.
  */
 
 /*
@@ -770,7 +810,7 @@ typedef int (PyArray_FinalizeFunc)(PyArrayObject *, PyObject *);
 
 /*
  * An array never has the next four set; they're only used as parameter
- * flags to the the various FromAny functions
+ * flags to the various FromAny functions
  *
  * This flag may be requested in constructor functions.
  */
@@ -802,7 +842,7 @@ typedef int (PyArray_FinalizeFunc)(PyArrayObject *, PyObject *);
 #define NPY_ARRAY_ELEMENTSTRIDES  0x0080
 
 /*
- * Array data is aligned on the appropiate memory address for the type
+ * Array data is aligned on the appropriate memory address for the type
  * stored according to how the compiler would align things (e.g., an
  * array of integers (4 bytes each) starts on a memory address that's
  * a multiple of 4)
@@ -830,12 +870,13 @@ typedef int (PyArray_FinalizeFunc)(PyArrayObject *, PyObject *);
 /*
  * If this flag is set, then base contains a pointer to an array of
  * the same size that should be updated with the current contents of
- * this array when this array is deallocated
+ * this array when PyArray_ResolveWritebackIfCopy is called.
  *
  * This flag may be requested in constructor functions.
  * This flag may be tested for in PyArray_FLAGS(arr).
  */
-#define NPY_ARRAY_UPDATEIFCOPY    0x1000
+#define NPY_ARRAY_UPDATEIFCOPY    0x1000 /* Deprecated in 1.14 */
+#define NPY_ARRAY_WRITEBACKIFCOPY 0x2000
 
 /*
  * NOTE: there are also internal flags defined in multiarray/arrayobject.h,
@@ -860,10 +901,14 @@ typedef int (PyArray_FinalizeFunc)(PyArrayObject *, PyObject *);
 #define NPY_ARRAY_OUT_ARRAY    (NPY_ARRAY_CARRAY)
 #define NPY_ARRAY_INOUT_ARRAY  (NPY_ARRAY_CARRAY | \
                                 NPY_ARRAY_UPDATEIFCOPY)
+#define NPY_ARRAY_INOUT_ARRAY2 (NPY_ARRAY_CARRAY | \
+                                NPY_ARRAY_WRITEBACKIFCOPY)
 #define NPY_ARRAY_IN_FARRAY    (NPY_ARRAY_FARRAY_RO)
 #define NPY_ARRAY_OUT_FARRAY   (NPY_ARRAY_FARRAY)
 #define NPY_ARRAY_INOUT_FARRAY (NPY_ARRAY_FARRAY | \
                                 NPY_ARRAY_UPDATEIFCOPY)
+#define NPY_ARRAY_INOUT_FARRAY2 (NPY_ARRAY_FARRAY | \
+                                NPY_ARRAY_WRITEBACKIFCOPY)
 
 #define NPY_ARRAY_UPDATE_ALL   (NPY_ARRAY_C_CONTIGUOUS | \
                                 NPY_ARRAY_F_CONTIGUOUS | \
@@ -904,26 +949,30 @@ typedef int (PyArray_FinalizeFunc)(PyArrayObject *, PyObject *);
  */
 
 
-#define PyArray_ISCONTIGUOUS(m) PyArray_CHKFLAGS(m, NPY_ARRAY_C_CONTIGUOUS)
-#define PyArray_ISWRITEABLE(m) PyArray_CHKFLAGS(m, NPY_ARRAY_WRITEABLE)
-#define PyArray_ISALIGNED(m) PyArray_CHKFLAGS(m, NPY_ARRAY_ALIGNED)
+#define PyArray_ISCONTIGUOUS(m) PyArray_CHKFLAGS((m), NPY_ARRAY_C_CONTIGUOUS)
+#define PyArray_ISWRITEABLE(m) PyArray_CHKFLAGS((m), NPY_ARRAY_WRITEABLE)
+#define PyArray_ISALIGNED(m) PyArray_CHKFLAGS((m), NPY_ARRAY_ALIGNED)
 
-#define PyArray_IS_C_CONTIGUOUS(m) PyArray_CHKFLAGS(m, NPY_ARRAY_C_CONTIGUOUS)
-#define PyArray_IS_F_CONTIGUOUS(m) PyArray_CHKFLAGS(m, NPY_ARRAY_F_CONTIGUOUS)
+#define PyArray_IS_C_CONTIGUOUS(m) PyArray_CHKFLAGS((m), NPY_ARRAY_C_CONTIGUOUS)
+#define PyArray_IS_F_CONTIGUOUS(m) PyArray_CHKFLAGS((m), NPY_ARRAY_F_CONTIGUOUS)
 
+/* the variable is used in some places, so always define it */
+#define NPY_BEGIN_THREADS_DEF PyThreadState *_save=NULL;
 #if NPY_ALLOW_THREADS
 #define NPY_BEGIN_ALLOW_THREADS Py_BEGIN_ALLOW_THREADS
 #define NPY_END_ALLOW_THREADS Py_END_ALLOW_THREADS
-#define NPY_BEGIN_THREADS_DEF PyThreadState *_save=NULL;
 #define NPY_BEGIN_THREADS do {_save = PyEval_SaveThread();} while (0);
-#define NPY_END_THREADS   do {if (_save) PyEval_RestoreThread(_save);} while (0);
+#define NPY_END_THREADS   do { if (_save) \
+                { PyEval_RestoreThread(_save); _save = NULL;} } while (0);
+#define NPY_BEGIN_THREADS_THRESHOLDED(loop_size) do { if ((loop_size) > 500) \
+                { _save = PyEval_SaveThread();} } while (0);
 
 #define NPY_BEGIN_THREADS_DESCR(dtype) \
-        do {if (!(PyDataType_FLAGCHK(dtype, NPY_NEEDS_PYAPI))) \
+        do {if (!(PyDataType_FLAGCHK((dtype), NPY_NEEDS_PYAPI))) \
                 NPY_BEGIN_THREADS;} while (0);
 
 #define NPY_END_THREADS_DESCR(dtype) \
-        do {if (!(PyDataType_FLAGCHK(dtype, NPY_NEEDS_PYAPI))) \
+        do {if (!(PyDataType_FLAGCHK((dtype), NPY_NEEDS_PYAPI))) \
                 NPY_END_THREADS; } while (0);
 
 #define NPY_ALLOW_C_API_DEF  PyGILState_STATE __save__;
@@ -932,9 +981,9 @@ typedef int (PyArray_FinalizeFunc)(PyArrayObject *, PyObject *);
 #else
 #define NPY_BEGIN_ALLOW_THREADS
 #define NPY_END_ALLOW_THREADS
-#define NPY_BEGIN_THREADS_DEF
 #define NPY_BEGIN_THREADS
 #define NPY_END_THREADS
+#define NPY_BEGIN_THREADS_THRESHOLDED(loop_size)
 #define NPY_BEGIN_THREADS_DESCR(dtype)
 #define NPY_END_THREADS_DESCR(dtype)
 #define NPY_ALLOW_C_API_DEF
@@ -982,6 +1031,12 @@ typedef void (NpyIter_GetMultiIndexFunc)(NpyIter *iter,
 #define NPY_ITER_DELAY_BUFALLOC             0x00000800
 /* When NPY_KEEPORDER is specified, disable reversing negative-stride axes */
 #define NPY_ITER_DONT_NEGATE_STRIDES        0x00001000
+/*
+ * If output operands overlap with other operands (based on heuristics that
+ * has false positives but no false negatives), make temporary copies to
+ * eliminate overlap.
+ */
+#define NPY_ITER_COPY_IF_OVERLAP            0x00002000
 
 /*** Per-operand flags that may be passed to the iterator constructors ***/
 
@@ -999,7 +1054,7 @@ typedef void (NpyIter_GetMultiIndexFunc)(NpyIter *iter,
 #define NPY_ITER_CONTIG                     0x00200000
 /* The operand may be copied to satisfy requirements */
 #define NPY_ITER_COPY                       0x00400000
-/* The operand may be copied with UPDATEIFCOPY to satisfy requirements */
+/* The operand may be copied with WRITEBACKIFCOPY to satisfy requirements */
 #define NPY_ITER_UPDATEIFCOPY               0x00800000
 /* Allocate the operand if it is NULL */
 #define NPY_ITER_ALLOCATE                   0x01000000
@@ -1013,6 +1068,8 @@ typedef void (NpyIter_GetMultiIndexFunc)(NpyIter *iter,
 #define NPY_ITER_WRITEMASKED                0x10000000
 /* This array is the mask for all WRITEMASKED operands */
 #define NPY_ITER_ARRAYMASK                  0x20000000
+/* Assume iterator order data access for COPY_IF_OVERLAP */
+#define NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE 0x40000000
 
 #define NPY_ITER_GLOBAL_FLAGS               0x0000ffff
 #define NPY_ITER_PER_OP_FLAGS               0xffff0000
@@ -1029,7 +1086,8 @@ typedef struct PyArrayIterObject_tag PyArrayIterObject;
  * type of the function which translates a set of coordinates to a
  * pointer to the data
  */
-typedef char* (*npy_iter_get_dataptr_t)(PyArrayIterObject* iter, npy_intp*);
+typedef char* (*npy_iter_get_dataptr_t)(
+        PyArrayIterObject* iter, const npy_intp*);
 
 struct PyArrayIterObject_tag {
         PyObject_HEAD
@@ -1052,7 +1110,7 @@ struct PyArrayIterObject_tag {
 
 
 /* Iterator API */
-#define PyArrayIter_Check(op) PyObject_TypeCheck(op, &PyArrayIter_Type)
+#define PyArrayIter_Check(op) PyObject_TypeCheck((op), &PyArrayIter_Type)
 
 #define _PyAIT(it) ((PyArrayIterObject *)(it))
 #define PyArray_ITER_RESET(it) do { \
@@ -1080,27 +1138,6 @@ struct PyArrayIterObject_tag {
         } \
 } while (0)
 
-#define _PyArray_ITER_NEXT3(it) do { \
-        if ((it)->coordinates[2] < (it)->dims_m1[2]) { \
-                (it)->coordinates[2]++; \
-                (it)->dataptr += (it)->strides[2]; \
-        } \
-        else { \
-                (it)->coordinates[2] = 0; \
-                (it)->dataptr -= (it)->backstrides[2]; \
-                if ((it)->coordinates[1] < (it)->dims_m1[1]) { \
-                        (it)->coordinates[1]++; \
-                        (it)->dataptr += (it)->strides[1]; \
-                } \
-                else { \
-                        (it)->coordinates[1] = 0; \
-                        (it)->coordinates[0]++; \
-                        (it)->dataptr += (it)->strides[0] \
-                                (it)->backstrides[1]; \
-                } \
-        } \
-} while (0)
-
 #define PyArray_ITER_NEXT(it) do { \
         _PyAIT(it)->index++; \
         if (_PyAIT(it)->nd_m1 == 0) { \
@@ -1151,7 +1188,7 @@ struct PyArrayIterObject_tag {
 
 #define PyArray_ITER_GOTO1D(it, ind) do { \
         int __npy_i; \
-        npy_intp __npy_ind = (npy_intp) (ind); \
+        npy_intp __npy_ind = (npy_intp)(ind); \
         if (__npy_ind < 0) __npy_ind += _PyAIT(it)->size; \
         _PyAIT(it)->index = __npy_ind; \
         if (_PyAIT(it)->nd_m1 == 0) { \
@@ -1235,8 +1272,12 @@ typedef struct {
 #define PyArray_MultiIter_NOTDONE(multi)                \
         (_PyMIT(multi)->index < _PyMIT(multi)->size)
 
-/* Store the information needed for fancy-indexing over an array */
 
+/*
+ * Store the information needed for fancy-indexing over an array. The
+ * fields are slightly unordered to keep consec, dataptr and subspace
+ * where they were originally.
+ */
 typedef struct {
         PyObject_HEAD
         /*
@@ -1251,29 +1292,71 @@ typedef struct {
         npy_intp              index;                   /* current index */
         int                   nd;                      /* number of dims */
         npy_intp              dimensions[NPY_MAXDIMS]; /* dimensions */
-        PyArrayIterObject     *iters[NPY_MAXDIMS];     /* index object
-                                                          iterators */
-        PyArrayIterObject     *ait;                    /* flat Iterator for
-                                                          underlying array */
+        NpyIter               *outer;                  /* index objects
+                                                          iterator */
+        void                  *unused[NPY_MAXDIMS - 2];
+        PyArrayObject         *array;
+        /* Flat iterator for the indexed array. For compatibility solely. */
+        PyArrayIterObject     *ait;
 
-        /* flat iterator for subspace (when numiter < nd) */
-        PyArrayIterObject     *subspace;
+        /*
+         * Subspace array. For binary compatibility (was an iterator,
+         * but only the check for NULL should be used).
+         */
+        PyArrayObject         *subspace;
 
         /*
          * if subspace iteration, then this is the array of axes in
          * the underlying array represented by the index objects
          */
         int                   iteraxes[NPY_MAXDIMS];
+        npy_intp              fancy_strides[NPY_MAXDIMS];
+
+        /* pointer when all fancy indices are 0 */
+        char                  *baseoffset;
+
         /*
-         * if subspace iteration, the these are the coordinates to the
-         * start of the subspace.
+         * after binding consec denotes at which axis the fancy axes
+         * are inserted.
          */
-        npy_intp              bscoord[NPY_MAXDIMS];
-
-        PyObject              *indexobj;               /* creating obj */
         int                   consec;
         char                  *dataptr;
 
+        int                   nd_fancy;
+        npy_intp              fancy_dims[NPY_MAXDIMS];
+
+        /* Whether the iterator (any of the iterators) requires API */
+        int                   needs_api;
+
+        /*
+         * Extra op information.
+         */
+        PyArrayObject         *extra_op;
+        PyArray_Descr         *extra_op_dtype;         /* desired dtype */
+        npy_uint32            *extra_op_flags;         /* Iterator flags */
+
+        NpyIter               *extra_op_iter;
+        NpyIter_IterNextFunc  *extra_op_next;
+        char                  **extra_op_ptrs;
+
+        /*
+         * Information about the iteration state.
+         */
+        NpyIter_IterNextFunc  *outer_next;
+        char                  **outer_ptrs;
+        npy_intp              *outer_strides;
+
+        /*
+         * Information about the subspace iterator.
+         */
+        NpyIter               *subspace_iter;
+        NpyIter_IterNextFunc  *subspace_next;
+        char                  **subspace_ptrs;
+        npy_intp              *subspace_strides;
+
+        /* Count for the external loop (which ever it is) for API iteration */
+        npy_intp              iter_count;
+
 } PyArrayMapIterObject;
 
 enum {
@@ -1365,17 +1448,16 @@ PyArrayNeighborhoodIter_Next2D(PyArrayNeighborhoodIterObject* iter);
  * checking of correctness when working with these objects in C.
  */
 
-#define PyArray_ISONESEGMENT(m) (PyArray_NDIM(m) == 0 || \
-                             PyArray_CHKFLAGS(m, NPY_ARRAY_C_CONTIGUOUS) || \
-                             PyArray_CHKFLAGS(m, NPY_ARRAY_F_CONTIGUOUS))
+#define PyArray_ISONESEGMENT(m) (PyArray_CHKFLAGS(m, NPY_ARRAY_C_CONTIGUOUS) || \
+                                 PyArray_CHKFLAGS(m, NPY_ARRAY_F_CONTIGUOUS))
 
 #define PyArray_ISFORTRAN(m) (PyArray_CHKFLAGS(m, NPY_ARRAY_F_CONTIGUOUS) && \
-                             (PyArray_NDIM(m) > 1))
+                             (!PyArray_CHKFLAGS(m, NPY_ARRAY_C_CONTIGUOUS)))
 
 #define PyArray_FORTRAN_IF(m) ((PyArray_CHKFLAGS(m, NPY_ARRAY_F_CONTIGUOUS) ? \
                                NPY_ARRAY_F_CONTIGUOUS : 0))
 
-#if (defined(NPY_NO_DEPRECATED_API) && (NPY_API_VERSION <= NPY_NO_DEPRECATED_API))
+#if (defined(NPY_NO_DEPRECATED_API) && (NPY_1_7_API_VERSION <= NPY_NO_DEPRECATED_API))
 /*
  * Changing access macros into functions, to allow for future hiding
  * of the internal memory layout. This later hiding will allow the 2.x series
@@ -1425,13 +1507,13 @@ PyArray_STRIDE(const PyArrayObject *arr, int istride)
     return ((PyArrayObject_fields *)arr)->strides[istride];
 }
 
-static NPY_INLINE PyObject *
+static NPY_INLINE NPY_RETURNS_BORROWED_REF PyObject *
 PyArray_BASE(PyArrayObject *arr)
 {
     return ((PyArrayObject_fields *)arr)->base;
 }
 
-static NPY_INLINE PyArray_Descr *
+static NPY_INLINE NPY_RETURNS_BORROWED_REF PyArray_Descr *
 PyArray_DESCR(PyArrayObject *arr)
 {
     return ((PyArrayObject_fields *)arr)->descr;
@@ -1588,7 +1670,7 @@ PyArray_CLEARFLAGS(PyArrayObject *arr, int flags)
 #define PyTypeNum_ISOBJECT(type) ((type) == NPY_OBJECT)
 
 
-#define PyDataType_ISBOOL(obj) PyTypeNum_ISBOOL(_PyADt(obj))
+#define PyDataType_ISBOOL(obj) PyTypeNum_ISBOOL(((PyArray_Descr*)(obj))->type_num)
 #define PyDataType_ISUNSIGNED(obj) PyTypeNum_ISUNSIGNED(((PyArray_Descr*)(obj))->type_num)
 #define PyDataType_ISSIGNED(obj) PyTypeNum_ISSIGNED(((PyArray_Descr*)(obj))->type_num)
 #define PyDataType_ISINTEGER(obj) PyTypeNum_ISINTEGER(((PyArray_Descr*)(obj))->type_num )
@@ -1604,6 +1686,9 @@ PyArray_CLEARFLAGS(PyArrayObject *arr, int flags)
 #define PyDataType_ISOBJECT(obj) PyTypeNum_ISOBJECT(((PyArray_Descr*)(obj))->type_num)
 #define PyDataType_HASFIELDS(obj) (((PyArray_Descr *)(obj))->names != NULL)
 #define PyDataType_HASSUBARRAY(dtype) ((dtype)->subarray != NULL)
+#define PyDataType_ISUNSIZED(dtype) ((dtype)->elsize == 0 && \
+                                      !PyDataType_HASFIELDS(dtype))
+#define PyDataType_MAKEUNSIZED(dtype) ((dtype)->elsize = 0)
 
 #define PyArray_ISBOOL(obj) PyTypeNum_ISBOOL(PyArray_TYPE(obj))
 #define PyArray_ISUNSIGNED(obj) PyTypeNum_ISUNSIGNED(PyArray_TYPE(obj))
@@ -1675,7 +1760,7 @@ typedef struct {
 /************************************************************
  * This is the form of the struct that's returned pointed by the
  * PyCObject attribute of an array __array_struct__. See
- * http://docs.scipy.org/doc/numpy/reference/arrays.interface.html for the full
+ * https://docs.scipy.org/doc/numpy/reference/arrays.interface.html for the full
  * documentation.
  ************************************************************/
 typedef struct {
@@ -1724,8 +1809,30 @@ typedef struct {
 typedef void (PyDataMem_EventHookFunc)(void *inp, void *outp, size_t size,
                                        void *user_data);
 
-#if !(defined(NPY_NO_DEPRECATED_API) && (NPY_API_VERSION <= NPY_NO_DEPRECATED_API))
-#include "npy_deprecated_api.h"
+/*
+ * Use the keyword NPY_DEPRECATED_INCLUDES to ensure that the header files
+ * npy_*_*_deprecated_api.h are only included from here and nowhere else.
+ */
+#ifdef NPY_DEPRECATED_INCLUDES
+#error "Do not use the reserved keyword NPY_DEPRECATED_INCLUDES."
 #endif
+#define NPY_DEPRECATED_INCLUDES
+#if !defined(NPY_NO_DEPRECATED_API) || \
+    (NPY_NO_DEPRECATED_API < NPY_1_7_API_VERSION)
+#include "npy_1_7_deprecated_api.h"
+#endif
+/*
+ * There is no file npy_1_8_deprecated_api.h since there are no additional
+ * deprecated API features in NumPy 1.8.
+ *
+ * Note to maintainers: insert code like the following in future NumPy
+ * versions.
+ *
+ * #if !defined(NPY_NO_DEPRECATED_API) || \
+ *     (NPY_NO_DEPRECATED_API < NPY_1_9_API_VERSION)
+ * #include "npy_1_9_deprecated_api.h"
+ * #endif
+ */
+#undef NPY_DEPRECATED_INCLUDES
 
 #endif /* NPY_ARRAYTYPES_H */
diff --git a/include/numpy/noprefix.h b/include/numpy/noprefix.h
index b3e57480e..041f30192 100644
--- a/include/numpy/noprefix.h
+++ b/include/numpy/noprefix.h
@@ -64,10 +64,13 @@
 #define datetime    npy_datetime
 #define timedelta   npy_timedelta
 
-#define SIZEOF_INTP NPY_SIZEOF_INTP
-#define SIZEOF_UINTP NPY_SIZEOF_UINTP
-#define SIZEOF_DATETIME NPY_SIZEOF_DATETIME
-#define SIZEOF_TIMEDELTA NPY_SIZEOF_TIMEDELTA
+#define SIZEOF_LONGLONG         NPY_SIZEOF_LONGLONG
+#define SIZEOF_INTP             NPY_SIZEOF_INTP
+#define SIZEOF_UINTP            NPY_SIZEOF_UINTP
+#define SIZEOF_HALF             NPY_SIZEOF_HALF
+#define SIZEOF_LONGDOUBLE       NPY_SIZEOF_LONGDOUBLE
+#define SIZEOF_DATETIME         NPY_SIZEOF_DATETIME
+#define SIZEOF_TIMEDELTA        NPY_SIZEOF_TIMEDELTA
 
 #define LONGLONG_FMT NPY_LONGLONG_FMT
 #define ULONGLONG_FMT NPY_ULONGLONG_FMT
@@ -113,9 +116,6 @@
 #define MIN_TIMEDELTA NPY_MIN_TIMEDELTA
 #define MAX_TIMEDELTA NPY_MAX_TIMEDELTA
 
-#define SIZEOF_LONGDOUBLE NPY_SIZEOF_LONGDOUBLE
-#define SIZEOF_LONGLONG   NPY_SIZEOF_LONGLONG
-#define SIZEOF_HALF       NPY_SIZEOF_HALF
 #define BITSOF_BOOL       NPY_BITSOF_BOOL
 #define BITSOF_CHAR       NPY_BITSOF_CHAR
 #define BITSOF_SHORT      NPY_BITSOF_SHORT
@@ -166,6 +166,7 @@
 #define NOTSWAPPED         NPY_NOTSWAPPED
 #define WRITEABLE          NPY_WRITEABLE
 #define UPDATEIFCOPY       NPY_UPDATEIFCOPY
+#define WRITEBACKIFCOPY    NPY_ARRAY_WRITEBACKIFCOPY
 #define ARR_HAS_DESCR      NPY_ARR_HAS_DESCR
 #define BEHAVED            NPY_BEHAVED
 #define BEHAVED_NS         NPY_BEHAVED_NS
@@ -203,7 +204,9 @@
 #define MAX_UINTP NPY_MAX_UINTP
 #define INTP_FMT NPY_INTP_FMT
 
+#ifndef PYPY_VERSION
 #define REFCOUNT PyArray_REFCOUNT
 #define MAX_ELSIZE NPY_MAX_ELSIZE
+#endif
 
 #endif
diff --git a/include/numpy/npy_3kcompat.h b/include/numpy/npy_3kcompat.h
index d0cd9ac1a..798da6957 100644
--- a/include/numpy/npy_3kcompat.h
+++ b/include/numpy/npy_3kcompat.h
@@ -13,11 +13,9 @@
 #include <Python.h>
 #include <stdio.h>
 
-#if PY_VERSION_HEX >= 0x03000000
 #ifndef NPY_PY3K
 #define NPY_PY3K 1
 #endif
-#endif
 
 #include "numpy/npy_common.h"
 #include "numpy/ndarrayobject.h"
@@ -45,6 +43,7 @@ static NPY_INLINE int PyInt_Check(PyObject *op) {
 #define PyInt_AsLong PyLong_AsLong
 #define PyInt_AS_LONG PyLong_AsLong
 #define PyInt_AsSsize_t PyLong_AsSsize_t
+#define PyNumber_Int PyNumber_Long
 
 /* NOTE:
  *
@@ -53,6 +52,50 @@ static NPY_INLINE int PyInt_Check(PyObject *op) {
  */
 #endif /* NPY_PY3K */
 
+/* Py3 changes PySlice_GetIndicesEx' first argument's type to PyObject* */
+#ifdef NPY_PY3K
+#  define NpySlice_GetIndicesEx PySlice_GetIndicesEx
+#else
+#  define NpySlice_GetIndicesEx(op, nop, start, end, step, slicelength) \
+    PySlice_GetIndicesEx((PySliceObject *)op, nop, start, end, step, slicelength)
+#endif
+
+#if PY_VERSION_HEX < 0x030900a4
+    /* Introduced in https://github.com/python/cpython/commit/d2ec81a8c99796b51fb8c49b77a7fe369863226f */
+    #define Py_SET_TYPE(obj, typ) (Py_TYPE(obj) = typ)
+    /* Introduced in https://github.com/python/cpython/commit/b10dc3e7a11fcdb97e285882eba6da92594f90f9 */
+    #define Py_SET_SIZE(obj, size) (Py_SIZE(obj) = size)
+#endif
+
+
+#define Npy_EnterRecursiveCall(x) Py_EnterRecursiveCall(x)
+
+/* Py_SETREF was added in 3.5.2, and only if Py_LIMITED_API is absent */
+#if PY_VERSION_HEX < 0x03050200
+    #define Py_SETREF(op, op2)                      \
+        do {                                        \
+            PyObject *_py_tmp = (PyObject *)(op);   \
+            (op) = (op2);                           \
+            Py_DECREF(_py_tmp);                     \
+        } while (0)
+#endif
+
+/* introduced in https://github.com/python/cpython/commit/a24107b04c1277e3c1105f98aff5bfa3a98b33a0 */
+#if PY_VERSION_HEX < 0x030800A3
+    static NPY_INLINE PyObject *
+    _PyDict_GetItemStringWithError(PyObject *v, const char *key)
+    {
+        PyObject *kv, *rv;
+        kv = PyUnicode_FromString(key);
+        if (kv == NULL) {
+            return NULL;
+        }
+        rv = PyDict_GetItemWithError(v, kv);
+        Py_DECREF(kv);
+        return rv;
+    }
+#endif
+
 /*
  * PyString -> PyBytes
  */
@@ -86,6 +129,8 @@ static NPY_INLINE int PyInt_Check(PyObject *op) {
 #define PyUString_InternFromString PyUnicode_InternFromString
 #define PyUString_Format PyUnicode_Format
 
+#define PyBaseString_Check(obj) (PyUnicode_Check(obj))
+
 #else
 
 #define PyBytes_Type PyString_Type
@@ -115,43 +160,46 @@ static NPY_INLINE int PyInt_Check(PyObject *op) {
 #define PyUString_InternFromString PyString_InternFromString
 #define PyUString_Format PyString_Format
 
+#define PyBaseString_Check(obj) (PyBytes_Check(obj) || PyUnicode_Check(obj))
+
 #endif /* NPY_PY3K */
 
 
 static NPY_INLINE void
 PyUnicode_ConcatAndDel(PyObject **left, PyObject *right)
 {
-    PyObject *newobj;
-    newobj = PyUnicode_Concat(*left, right);
-    Py_DECREF(*left);
+    Py_SETREF(*left, PyUnicode_Concat(*left, right));
     Py_DECREF(right);
-    *left = newobj;
 }
 
 static NPY_INLINE void
 PyUnicode_Concat2(PyObject **left, PyObject *right)
 {
-    PyObject *newobj;
-    newobj = PyUnicode_Concat(*left, right);
-    Py_DECREF(*left);
-    *left = newobj;
+    Py_SETREF(*left, PyUnicode_Concat(*left, right));
 }
 
 /*
  * PyFile_* compatibility
  */
-#if defined(NPY_PY3K)
 
 /*
  * Get a FILE* handle to the file represented by the Python object
  */
 static NPY_INLINE FILE*
-npy_PyFile_Dup(PyObject *file, char *mode)
+npy_PyFile_Dup2(PyObject *file, char *mode, npy_off_t *orig_pos)
 {
-    int fd, fd2;
-    PyObject *ret, *os;
-    Py_ssize_t pos;
+    int fd, fd2, unbuf;
+    PyObject *ret, *os, *io, *io_raw;
+    npy_off_t pos;
     FILE *handle;
+
+    /* For Python 2 PyFileObject, use PyFile_AsFile */
+#if !defined(NPY_PY3K)
+    if (PyFile_Check(file)) {
+        return PyFile_AsFile(file);
+    }
+#endif
+
     /* Flush first to ensure things end up in the file in the correct order */
     ret = PyObject_CallMethod(file, "flush", "");
     if (ret == NULL) {
@@ -162,6 +210,11 @@ npy_PyFile_Dup(PyObject *file, char *mode)
     if (fd == -1) {
         return NULL;
     }
+
+    /*
+     * The handle needs to be dup'd because we have to call fclose
+     * at the end
+     */
     os = PyImport_ImportModule("os");
     if (os == NULL) {
         return NULL;
@@ -173,6 +226,8 @@ npy_PyFile_Dup(PyObject *file, char *mode)
     }
     fd2 = PyNumber_AsSsize_t(ret, NULL);
     Py_DECREF(ret);
+
+    /* Convert to FILE* handle */
 #ifdef _WIN32
     handle = _fdopen(fd2, mode);
 #else
@@ -181,19 +236,55 @@ npy_PyFile_Dup(PyObject *file, char *mode)
     if (handle == NULL) {
         PyErr_SetString(PyExc_IOError,
                         "Getting a FILE* from a Python file object failed");
+        return NULL;
     }
+
+    /* Record the original raw file handle position */
+    *orig_pos = npy_ftell(handle);
+    if (*orig_pos == -1) {
+        /* The io module is needed to determine if buffering is used */
+        io = PyImport_ImportModule("io");
+        if (io == NULL) {
+            fclose(handle);
+            return NULL;
+        }
+        /* File object instances of RawIOBase are unbuffered */
+        io_raw = PyObject_GetAttrString(io, "RawIOBase");
+        Py_DECREF(io);
+        if (io_raw == NULL) {
+            fclose(handle);
+            return NULL;
+        }
+        unbuf = PyObject_IsInstance(file, io_raw);
+        Py_DECREF(io_raw);
+        if (unbuf == 1) {
+            /* Succeed if the IO is unbuffered */
+            return handle;
+        }
+        else {
+            PyErr_SetString(PyExc_IOError, "obtaining file position failed");
+            fclose(handle);
+            return NULL;
+        }
+    }
+
+    /* Seek raw handle to the Python-side position */
     ret = PyObject_CallMethod(file, "tell", "");
     if (ret == NULL) {
         fclose(handle);
         return NULL;
     }
-    pos = PyNumber_AsSsize_t(ret, PyExc_OverflowError);
+    pos = PyLong_AsLongLong(ret);
     Py_DECREF(ret);
     if (PyErr_Occurred()) {
         fclose(handle);
         return NULL;
     }
-    npy_fseek(handle, pos, SEEK_SET);
+    if (npy_fseek(handle, pos, SEEK_SET) == -1) {
+        PyErr_SetString(PyExc_IOError, "seeking file failed");
+        fclose(handle);
+        return NULL;
+    }
     return handle;
 }
 
@@ -201,14 +292,65 @@ npy_PyFile_Dup(PyObject *file, char *mode)
  * Close the dup-ed file handle, and seek the Python one to the current position
  */
 static NPY_INLINE int
-npy_PyFile_DupClose(PyObject *file, FILE* handle)
+npy_PyFile_DupClose2(PyObject *file, FILE* handle, npy_off_t orig_pos)
 {
-    PyObject *ret;
-    Py_ssize_t position;
+    int fd, unbuf;
+    PyObject *ret, *io, *io_raw;
+    npy_off_t position;
+
+    /* For Python 2 PyFileObject, do nothing */
+#if !defined(NPY_PY3K)
+    if (PyFile_Check(file)) {
+        return 0;
+    }
+#endif
+
     position = npy_ftell(handle);
+
+    /* Close the FILE* handle */
     fclose(handle);
 
-    ret = PyObject_CallMethod(file, "seek", NPY_SSIZE_T_PYFMT "i", position, 0);
+    /*
+     * Restore original file handle position, in order to not confuse
+     * Python-side data structures
+     */
+    fd = PyObject_AsFileDescriptor(file);
+    if (fd == -1) {
+        return -1;
+    }
+
+    if (npy_lseek(fd, orig_pos, SEEK_SET) == -1) {
+
+        /* The io module is needed to determine if buffering is used */
+        io = PyImport_ImportModule("io");
+        if (io == NULL) {
+            return -1;
+        }
+        /* File object instances of RawIOBase are unbuffered */
+        io_raw = PyObject_GetAttrString(io, "RawIOBase");
+        Py_DECREF(io);
+        if (io_raw == NULL) {
+            return -1;
+        }
+        unbuf = PyObject_IsInstance(file, io_raw);
+        Py_DECREF(io_raw);
+        if (unbuf == 1) {
+            /* Succeed if the IO is unbuffered */
+            return 0;
+        }
+        else {
+            PyErr_SetString(PyExc_IOError, "seeking file failed");
+            return -1;
+        }
+    }
+
+    if (position == -1) {
+        PyErr_SetString(PyExc_IOError, "obtaining file position failed");
+        return -1;
+    }
+
+    /* Seek Python-side handle to the FILE* handle position */
+    ret = PyObject_CallMethod(file, "seek", NPY_OFF_T_PYFMT "i", position, 0);
     if (ret == NULL) {
         return -1;
     }
@@ -220,6 +362,12 @@ static NPY_INLINE int
 npy_PyFile_Check(PyObject *file)
 {
     int fd;
+    /* For Python 2, check if it is a PyFileObject */
+#if !defined(NPY_PY3K)
+    if (PyFile_Check(file)) {
+        return 1;
+    }
+#endif
     fd = PyObject_AsFileDescriptor(file);
     if (fd == -1) {
         PyErr_Clear();
@@ -228,14 +376,6 @@ npy_PyFile_Check(PyObject *file)
     return 1;
 }
 
-#else
-
-#define npy_PyFile_Dup(file, mode) PyFile_AsFile(file)
-#define npy_PyFile_DupClose(file, handle) (0)
-#define npy_PyFile_Check PyFile_Check
-
-#endif
-
 static NPY_INLINE PyObject*
 npy_PyFile_OpenFile(PyObject *filename, const char *mode)
 {
@@ -260,6 +400,68 @@ npy_PyFile_CloseFile(PyObject *file)
     return 0;
 }
 
+
+/* This is a copy of _PyErr_ChainExceptions
+ */
+static NPY_INLINE void
+npy_PyErr_ChainExceptions(PyObject *exc, PyObject *val, PyObject *tb)
+{
+    if (exc == NULL)
+        return;
+
+    if (PyErr_Occurred()) {
+        /* only py3 supports this anyway */
+        #ifdef NPY_PY3K
+            PyObject *exc2, *val2, *tb2;
+            PyErr_Fetch(&exc2, &val2, &tb2);
+            PyErr_NormalizeException(&exc, &val, &tb);
+            if (tb != NULL) {
+                PyException_SetTraceback(val, tb);
+                Py_DECREF(tb);
+            }
+            Py_DECREF(exc);
+            PyErr_NormalizeException(&exc2, &val2, &tb2);
+            PyException_SetContext(val2, val);
+            PyErr_Restore(exc2, val2, tb2);
+        #endif
+    }
+    else {
+        PyErr_Restore(exc, val, tb);
+    }
+}
+
+
+/* This is a copy of _PyErr_ChainExceptions, with:
+ *  - a minimal implementation for python 2
+ *  - __cause__ used instead of __context__
+ */
+static NPY_INLINE void
+npy_PyErr_ChainExceptionsCause(PyObject *exc, PyObject *val, PyObject *tb)
+{
+    if (exc == NULL)
+        return;
+
+    if (PyErr_Occurred()) {
+        /* only py3 supports this anyway */
+        #ifdef NPY_PY3K
+            PyObject *exc2, *val2, *tb2;
+            PyErr_Fetch(&exc2, &val2, &tb2);
+            PyErr_NormalizeException(&exc, &val, &tb);
+            if (tb != NULL) {
+                PyException_SetTraceback(val, tb);
+                Py_DECREF(tb);
+            }
+            Py_DECREF(exc);
+            PyErr_NormalizeException(&exc2, &val2, &tb2);
+            PyException_SetCause(val2, val);
+            PyErr_Restore(exc2, val2, tb2);
+        #endif
+    }
+    else {
+        PyErr_Restore(exc, val, tb);
+    }
+}
+
 /*
  * PyObject_Cmp
  */
@@ -269,7 +471,7 @@ PyObject_Cmp(PyObject *i1, PyObject *i2, int *cmp)
 {
     int v;
     v = PyObject_RichCompareBool(i1, i2, Py_LT);
-    if (v == 0) {
+    if (v == 1) {
         *cmp = -1;
         return 1;
     }
@@ -278,7 +480,7 @@ PyObject_Cmp(PyObject *i1, PyObject *i2, int *cmp)
     }
 
     v = PyObject_RichCompareBool(i1, i2, Py_GT);
-    if (v == 0) {
+    if (v == 1) {
         *cmp = 1;
         return 1;
     }
@@ -287,7 +489,7 @@ PyObject_Cmp(PyObject *i1, PyObject *i2, int *cmp)
     }
 
     v = PyObject_RichCompareBool(i1, i2, Py_EQ);
-    if (v == 0) {
+    if (v == 1) {
         *cmp = 0;
         return 1;
     }
@@ -304,8 +506,6 @@ PyObject_Cmp(PyObject *i1, PyObject *i2, int *cmp)
  * The main job here is to get rid of the improved error handling
  * of PyCapsules. It's a shame...
  */
-#if PY_VERSION_HEX >= 0x03000000
-
 static NPY_INLINE PyObject *
 NpyCapsule_FromVoidPtr(void *ptr, void (*dtor)(PyObject *))
 {
@@ -350,68 +550,9 @@ NpyCapsule_Check(PyObject *ptr)
     return PyCapsule_CheckExact(ptr);
 }
 
-static NPY_INLINE void
-simple_capsule_dtor(PyObject *cap)
-{
-    PyArray_free(PyCapsule_GetPointer(cap, NULL));
-}
-
-#else
-
-static NPY_INLINE PyObject *
-NpyCapsule_FromVoidPtr(void *ptr, void (*dtor)(void *))
-{
-    return PyCObject_FromVoidPtr(ptr, dtor);
-}
-
-static NPY_INLINE PyObject *
-NpyCapsule_FromVoidPtrAndDesc(void *ptr, void* context,
-        void (*dtor)(void *, void *))
-{
-    return PyCObject_FromVoidPtrAndDesc(ptr, context, dtor);
-}
-
-static NPY_INLINE void *
-NpyCapsule_AsVoidPtr(PyObject *ptr)
-{
-    return PyCObject_AsVoidPtr(ptr);
-}
-
-static NPY_INLINE void *
-NpyCapsule_GetDesc(PyObject *obj)
-{
-    return PyCObject_GetDesc(obj);
-}
-
-static NPY_INLINE int
-NpyCapsule_Check(PyObject *ptr)
-{
-    return PyCObject_Check(ptr);
-}
-
-static NPY_INLINE void
-simple_capsule_dtor(void *ptr)
-{
-    PyArray_free(ptr);
-}
-
-#endif
-
-/*
- * Hash value compatibility.
- * As of Python 3.2 hash values are of type Py_hash_t.
- * Previous versions use C long.
- */
-#if PY_VERSION_HEX < 0x03020000
-typedef long npy_hash_t;
-#define NPY_SIZEOF_HASH_T NPY_SIZEOF_LONG
-#else
-typedef Py_hash_t npy_hash_t;
-#define NPY_SIZEOF_HASH_T NPY_SIZEOF_INTP
-#endif
-
 #ifdef __cplusplus
 }
 #endif
 
+
 #endif /* _NPY_3KCOMPAT_H_ */
diff --git a/include/numpy/npy_common.h b/include/numpy/npy_common.h
index 7fca7e220..c2e755958 100644
--- a/include/numpy/npy_common.h
+++ b/include/numpy/npy_common.h
@@ -3,27 +3,213 @@
 
 /* numpconfig.h is auto-generated */
 #include "numpyconfig.h"
+#ifdef HAVE_NPY_CONFIG_H
+#include <npy_config.h>
+#endif
+
+/* need Python.h for npy_intp, npy_uintp */
+#include <Python.h>
+
+/*
+ * using static inline modifiers when defining npy_math functions
+ * allows the compiler to make optimizations when possible
+ */
+#if defined(NPY_INTERNAL_BUILD) && NPY_INTERNAL_BUILD
+#ifndef NPY_INLINE_MATH
+#define NPY_INLINE_MATH 1
+#endif
+#endif
+
+/*
+ * gcc does not unroll even with -O3
+ * use with care, unrolling on modern cpus rarely speeds things up
+ */
+#ifdef HAVE_ATTRIBUTE_OPTIMIZE_UNROLL_LOOPS
+#define NPY_GCC_UNROLL_LOOPS \
+    __attribute__((optimize("unroll-loops")))
+#else
+#define NPY_GCC_UNROLL_LOOPS
+#endif
+
+/* highest gcc optimization level, enabled autovectorizer */
+#ifdef HAVE_ATTRIBUTE_OPTIMIZE_OPT_3
+#define NPY_GCC_OPT_3 __attribute__((optimize("O3")))
+#else
+#define NPY_GCC_OPT_3
+#endif
+
+/* compile target attributes */
+#if defined HAVE_ATTRIBUTE_TARGET_AVX && defined HAVE_LINK_AVX
+#define NPY_GCC_TARGET_AVX __attribute__((target("avx")))
+#else
+#define NPY_GCC_TARGET_AVX
+#endif
+
+#if defined HAVE_ATTRIBUTE_TARGET_AVX2_WITH_INTRINSICS
+#define HAVE_ATTRIBUTE_TARGET_FMA
+#define NPY_GCC_TARGET_FMA __attribute__((target("avx2,fma")))
+#endif
+
+#if defined HAVE_ATTRIBUTE_TARGET_AVX2 && defined HAVE_LINK_AVX2
+#define NPY_GCC_TARGET_AVX2 __attribute__((target("avx2")))
+#else
+#define NPY_GCC_TARGET_AVX2
+#endif
+
+#if defined HAVE_ATTRIBUTE_TARGET_AVX512F && defined HAVE_LINK_AVX512F
+#define NPY_GCC_TARGET_AVX512F __attribute__((target("avx512f")))
+#elif defined HAVE_ATTRIBUTE_TARGET_AVX512F_WITH_INTRINSICS
+#define NPY_GCC_TARGET_AVX512F __attribute__((target("avx512f")))
+#else
+#define NPY_GCC_TARGET_AVX512F
+#endif
+
+/*
+ * mark an argument (starting from 1) that must not be NULL and is not checked
+ * DO NOT USE IF FUNCTION CHECKS FOR NULL!! the compiler will remove the check
+ */
+#ifdef HAVE_ATTRIBUTE_NONNULL
+#define NPY_GCC_NONNULL(n) __attribute__((nonnull(n)))
+#else
+#define NPY_GCC_NONNULL(n)
+#endif
+
+#if defined HAVE_XMMINTRIN_H && defined HAVE__MM_LOAD_PS
+#define NPY_HAVE_SSE_INTRINSICS
+#endif
+
+#if defined HAVE_EMMINTRIN_H && defined HAVE__MM_LOAD_PD
+#define NPY_HAVE_SSE2_INTRINSICS
+#endif
+
+#if defined HAVE_IMMINTRIN_H && defined HAVE_LINK_AVX2
+#define NPY_HAVE_AVX2_INTRINSICS
+#endif
+
+#if defined HAVE_IMMINTRIN_H && defined HAVE_LINK_AVX512F
+#define NPY_HAVE_AVX512F_INTRINSICS
+#endif
+/*
+ * give a hint to the compiler which branch is more likely or unlikely
+ * to occur, e.g. rare error cases:
+ *
+ * if (NPY_UNLIKELY(failure == 0))
+ *    return NULL;
+ *
+ * the double !! is to cast the expression (e.g. NULL) to a boolean required by
+ * the intrinsic
+ */
+#ifdef HAVE___BUILTIN_EXPECT
+#define NPY_LIKELY(x) __builtin_expect(!!(x), 1)
+#define NPY_UNLIKELY(x) __builtin_expect(!!(x), 0)
+#else
+#define NPY_LIKELY(x) (x)
+#define NPY_UNLIKELY(x) (x)
+#endif
+
+#ifdef HAVE___BUILTIN_PREFETCH
+/* unlike _mm_prefetch also works on non-x86 */
+#define NPY_PREFETCH(x, rw, loc) __builtin_prefetch((x), (rw), (loc))
+#else
+#ifdef HAVE__MM_PREFETCH
+/* _MM_HINT_ET[01] (rw = 1) unsupported, only available in gcc >= 4.9 */
+#define NPY_PREFETCH(x, rw, loc) _mm_prefetch((x), loc == 0 ? _MM_HINT_NTA : \
+                                             (loc == 1 ? _MM_HINT_T2 : \
+                                              (loc == 2 ? _MM_HINT_T1 : \
+                                               (loc == 3 ? _MM_HINT_T0 : -1))))
+#else
+#define NPY_PREFETCH(x, rw,loc)
+#endif
+#endif
 
 #if defined(_MSC_VER)
         #define NPY_INLINE __inline
 #elif defined(__GNUC__)
-	#if defined(__STRICT_ANSI__)
-		#define NPY_INLINE __inline__
-	#else
-		#define NPY_INLINE inline
-	#endif
+    #if defined(__STRICT_ANSI__)
+         #define NPY_INLINE __inline__
+    #else
+         #define NPY_INLINE inline
+    #endif
+#else
+    #define NPY_INLINE
+#endif
+
+#ifdef HAVE___THREAD
+    #define NPY_TLS __thread
+#else
+    #ifdef HAVE___DECLSPEC_THREAD_
+        #define NPY_TLS __declspec(thread)
+    #else
+        #define NPY_TLS
+    #endif
+#endif
+
+#ifdef WITH_CPYCHECKER_RETURNS_BORROWED_REF_ATTRIBUTE
+  #define NPY_RETURNS_BORROWED_REF \
+    __attribute__((cpychecker_returns_borrowed_ref))
 #else
-        #define NPY_INLINE
+  #define NPY_RETURNS_BORROWED_REF
+#endif
+
+#ifdef WITH_CPYCHECKER_STEALS_REFERENCE_TO_ARG_ATTRIBUTE
+  #define NPY_STEALS_REF_TO_ARG(n) \
+   __attribute__((cpychecker_steals_reference_to_arg(n)))
+#else
+ #define NPY_STEALS_REF_TO_ARG(n)
+#endif
+
+/* 64 bit file position support, also on win-amd64. Ticket #1660 */
+#if defined(_MSC_VER) && defined(_WIN64) && (_MSC_VER > 1400) || \
+    defined(__MINGW32__) || defined(__MINGW64__)
+    #include <io.h>
+
+/* mingw based on 3.4.5 has lseek but not ftell/fseek */
+#if defined(__MINGW32__) || defined(__MINGW64__)
+extern int __cdecl _fseeki64(FILE *, long long, int);
+extern long long __cdecl _ftelli64(FILE *);
 #endif
 
-/* Enable 64 bit file position support on win-amd64. Ticket #1660 */
-#if defined(_MSC_VER) && defined(_WIN64) && (_MSC_VER > 1400)
     #define npy_fseek _fseeki64
     #define npy_ftell _ftelli64
+    #define npy_lseek _lseeki64
+    #define npy_off_t npy_int64
+
+    #if NPY_SIZEOF_INT == 8
+        #define NPY_OFF_T_PYFMT "i"
+    #elif NPY_SIZEOF_LONG == 8
+        #define NPY_OFF_T_PYFMT "l"
+    #elif NPY_SIZEOF_LONGLONG == 8
+        #define NPY_OFF_T_PYFMT "L"
+    #else
+        #error Unsupported size for type off_t
+    #endif
+#else
+#ifdef HAVE_FSEEKO
+    #define npy_fseek fseeko
 #else
     #define npy_fseek fseek
+#endif
+#ifdef HAVE_FTELLO
+    #define npy_ftell ftello
+#else
     #define npy_ftell ftell
 #endif
+    #include <sys/types.h>
+    #define npy_lseek lseek
+    #define npy_off_t off_t
+
+    #if NPY_SIZEOF_OFF_T == NPY_SIZEOF_SHORT
+        #define NPY_OFF_T_PYFMT "h"
+    #elif NPY_SIZEOF_OFF_T == NPY_SIZEOF_INT
+        #define NPY_OFF_T_PYFMT "i"
+    #elif NPY_SIZEOF_OFF_T == NPY_SIZEOF_LONG
+        #define NPY_OFF_T_PYFMT "l"
+    #elif NPY_SIZEOF_OFF_T == NPY_SIZEOF_LONGLONG
+        #define NPY_OFF_T_PYFMT "L"
+    #else
+        #error Unsupported size for type off_t
+    #endif
+#endif
 
 /* enums for detected endianness */
 enum {
@@ -33,15 +219,22 @@ enum {
 };
 
 /*
- * This is to typedef npy_intp to the appropriate pointer size for
- * this platform.  Py_intptr_t, Py_uintptr_t are defined in pyport.h.
+ * This is to typedef npy_intp to the appropriate pointer size for this
+ * platform.  Py_intptr_t, Py_uintptr_t are defined in pyport.h.
  */
 typedef Py_intptr_t npy_intp;
 typedef Py_uintptr_t npy_uintp;
+
+/*
+ * Define sizes that were not defined in numpyconfig.h.
+ */
 #define NPY_SIZEOF_CHAR 1
 #define NPY_SIZEOF_BYTE 1
+#define NPY_SIZEOF_DATETIME 8
+#define NPY_SIZEOF_TIMEDELTA 8
 #define NPY_SIZEOF_INTP NPY_SIZEOF_PY_INTPTR_T
 #define NPY_SIZEOF_UINTP NPY_SIZEOF_PY_INTPTR_T
+#define NPY_SIZEOF_HALF 2
 #define NPY_SIZEOF_CFLOAT NPY_SIZEOF_COMPLEX_FLOAT
 #define NPY_SIZEOF_CDOUBLE NPY_SIZEOF_COMPLEX_DOUBLE
 #define NPY_SIZEOF_CLONGDOUBLE NPY_SIZEOF_COMPLEX_LONGDOUBLE
@@ -50,18 +243,8 @@ typedef Py_uintptr_t npy_uintp;
 #undef constchar
 #endif
 
-#if (PY_VERSION_HEX < 0x02050000)
-  #ifndef PY_SSIZE_T_MIN
-    typedef int Py_ssize_t;
-    #define PY_SSIZE_T_MAX INT_MAX
-    #define PY_SSIZE_T_MIN INT_MIN
-  #endif
-#define NPY_SSIZE_T_PYFMT "i"
-#define constchar const char
-#else
 #define NPY_SSIZE_T_PYFMT "n"
 #define constchar char
-#endif
 
 /* NPY_INTP_FMT Note:
  *      Unlike the other NPY_*_FMT macros which are used with
@@ -69,10 +252,6 @@ typedef Py_uintptr_t npy_uintp;
  *      PyString_Format. These functions use different formatting
  *      codes which are portably specified according to the Python
  *      documentation. See ticket #1795.
- *
- *      On Windows x64, the LONGLONG formatter should be used, but
- *      in Python 2.6 the %lld formatter is not supported. In this
- *      case we work around the problem by using the %zd formatter.
  */
 #if NPY_SIZEOF_PY_INTPTR_T == NPY_SIZEOF_INT
         #define NPY_INTP NPY_INT
@@ -100,11 +279,7 @@ typedef Py_uintptr_t npy_uintp;
         #define NPY_MAX_INTP NPY_MAX_LONGLONG
         #define NPY_MIN_INTP NPY_MIN_LONGLONG
         #define NPY_MAX_UINTP NPY_MAX_ULONGLONG
-    #if (PY_VERSION_HEX >= 0x02070000)
         #define NPY_INTP_FMT "lld"
-    #else
-        #define NPY_INTP_FMT "zd"
-    #endif
 #endif
 
 /*
@@ -143,18 +318,9 @@ typedef unsigned PY_LONG_LONG npy_ulonglong;
 #  ifdef _MSC_VER
 #    define NPY_LONGLONG_FMT         "I64d"
 #    define NPY_ULONGLONG_FMT        "I64u"
-#  elif defined(__APPLE__) || defined(__FreeBSD__)
-/*   "%Ld" only parses 4 bytes -- "L" is floating modifier on MacOS X/BSD */
+#  else
 #    define NPY_LONGLONG_FMT         "lld"
 #    define NPY_ULONGLONG_FMT        "llu"
-/*
-     another possible variant -- *quad_t works on *BSD, but is deprecated:
-     #define LONGLONG_FMT   "qd"
-     #define ULONGLONG_FMT   "qu"
-*/
-#  else
-#    define NPY_LONGLONG_FMT         "Ld"
-#    define NPY_ULONGLONG_FMT        "Lu"
 #  endif
 #  ifdef _MSC_VER
 #    define NPY_LONGLONG_SUFFIX(x)   (x##i64)
@@ -203,6 +369,9 @@ typedef long npy_long;
 typedef float npy_float;
 typedef double npy_double;
 
+typedef Py_hash_t npy_hash_t;
+#define NPY_SIZEOF_HASH_T NPY_SIZEOF_INTP
+
 /*
  * Disabling C99 complex usage: a lot of C code in numpy/scipy rely on being
  * able to do .real/.imag. Will have to convert code first.
@@ -228,21 +397,21 @@ typedef struct {npy_longdouble real, imag;} npy_clongdouble;
 #endif
 #if NPY_SIZEOF_COMPLEX_DOUBLE != 2 * NPY_SIZEOF_DOUBLE
 #error npy_cdouble definition is not compatible with C99 complex definition ! \
-        Please contact Numpy maintainers and give detailed information about your \
+        Please contact NumPy maintainers and give detailed information about your \
         compiler and platform
 #endif
 typedef struct { double real, imag; } npy_cdouble;
 
 #if NPY_SIZEOF_COMPLEX_FLOAT != 2 * NPY_SIZEOF_FLOAT
 #error npy_cfloat definition is not compatible with C99 complex definition ! \
-        Please contact Numpy maintainers and give detailed information about your \
+        Please contact NumPy maintainers and give detailed information about your \
         compiler and platform
 #endif
 typedef struct { float real, imag; } npy_cfloat;
 
 #if NPY_SIZEOF_COMPLEX_LONGDOUBLE != 2 * NPY_SIZEOF_LONGDOUBLE
 #error npy_clongdouble definition is not compatible with C99 complex definition ! \
-        Please contact Numpy maintainers and give detailed information about your \
+        Please contact NumPy maintainers and give detailed information about your \
         compiler and platform
 #endif
 typedef struct { npy_longdouble real, imag; } npy_clongdouble;
@@ -305,10 +474,6 @@ typedef struct { npy_longdouble real, imag; } npy_clongdouble;
 #define NPY_MIN_LONG  LONG_MIN
 #define NPY_MAX_ULONG  ULONG_MAX
 
-#define NPY_SIZEOF_HALF 2
-#define NPY_SIZEOF_DATETIME 8
-#define NPY_SIZEOF_TIMEDELTA 8
-
 #define NPY_BITSOF_BOOL (sizeof(npy_bool) * CHAR_BIT)
 #define NPY_BITSOF_CHAR CHAR_BIT
 #define NPY_BITSOF_BYTE (NPY_SIZEOF_BYTE * CHAR_BIT)
@@ -927,4 +1092,3 @@ typedef npy_int64 npy_datetime;
 /* End of typedefs for numarray style bit-width names */
 
 #endif
-
diff --git a/include/numpy/npy_cpu.h b/include/numpy/npy_cpu.h
index 9707a7adf..509e23a51 100644
--- a/include/numpy/npy_cpu.h
+++ b/include/numpy/npy_cpu.h
@@ -5,6 +5,7 @@
  *              NPY_CPU_AMD64
  *              NPY_CPU_PPC
  *              NPY_CPU_PPC64
+ *              NPY_CPU_PPC64LE
  *              NPY_CPU_SPARC
  *              NPY_CPU_S390
  *              NPY_CPU_IA64
@@ -14,11 +15,16 @@
  *              NPY_CPU_ARMEB
  *              NPY_CPU_SH_LE
  *              NPY_CPU_SH_BE
+ *              NPY_CPU_ARCEL
+ *              NPY_CPU_ARCEB
+ *              NPY_CPU_RISCV64
+ *              NPY_CPU_WASM
  */
 #ifndef _NPY_CPUARCH_H_
 #define _NPY_CPUARCH_H_
 
 #include "numpyconfig.h"
+#include <string.h> /* for memcpy */
 
 #if defined( __i386__ ) || defined(i386) || defined(_M_IX86)
     /*
@@ -34,15 +40,19 @@
      * _M_AMD64 defined by MS compiler
      */
     #define NPY_CPU_AMD64
+#elif defined(__powerpc64__) && defined(__LITTLE_ENDIAN__)
+    #define NPY_CPU_PPC64LE
+#elif defined(__powerpc64__) && defined(__BIG_ENDIAN__)
+    #define NPY_CPU_PPC64
 #elif defined(__ppc__) || defined(__powerpc__) || defined(_ARCH_PPC)
     /*
      * __ppc__ is defined by gcc, I remember having seen __powerpc__ once,
      * but can't find it ATM
      * _ARCH_PPC is used by at least gcc on AIX
+     * As __powerpc__ and _ARCH_PPC are also defined by PPC64 check
+     * for those specifically first before defaulting to ppc
      */
     #define NPY_CPU_PPC
-#elif defined(__ppc64__)
-    #define NPY_CPU_PPC64
 #elif defined(__sparc__) || defined(__sparc)
     /* __sparc__ is defined by gcc and Forte (e.g. Sun) compilers */
     #define NPY_CPU_SPARC
@@ -54,10 +64,27 @@
     #define NPY_CPU_HPPA
 #elif defined(__alpha__)
     #define NPY_CPU_ALPHA
-#elif defined(__arm__) && defined(__ARMEL__)
-    #define NPY_CPU_ARMEL
-#elif defined(__arm__) && defined(__ARMEB__)
-    #define NPY_CPU_ARMEB
+#elif defined(__arm__) || defined(__aarch64__)
+    #if defined(__ARMEB__) || defined(__AARCH64EB__)
+        #if defined(__ARM_32BIT_STATE)
+            #define NPY_CPU_ARMEB_AARCH32
+        #elif defined(__ARM_64BIT_STATE)
+            #define NPY_CPU_ARMEB_AARCH64
+        #else
+            #define NPY_CPU_ARMEB
+        #endif
+    #elif defined(__ARMEL__) || defined(__AARCH64EL__)
+        #if defined(__ARM_32BIT_STATE)
+            #define NPY_CPU_ARMEL_AARCH32
+        #elif defined(__ARM_64BIT_STATE)
+            #define NPY_CPU_ARMEL_AARCH64
+        #else
+            #define NPY_CPU_ARMEL
+        #endif
+    #else
+        # error Unknown ARM CPU, please report this to numpy maintainers with \
+	information about your platform (OS, CPU and compiler)
+    #endif
 #elif defined(__sh__) && defined(__LITTLE_ENDIAN__)
     #define NPY_CPU_SH_LE
 #elif defined(__sh__) && defined(__BIG_ENDIAN__)
@@ -66,44 +93,30 @@
     #define NPY_CPU_MIPSEL
 #elif defined(__MIPSEB__)
     #define NPY_CPU_MIPSEB
-#elif defined(__aarch64__)
-    #define NPY_CPU_AARCH64
+#elif defined(__or1k__)
+    #define NPY_CPU_OR1K
+#elif defined(__mc68000__)
+    #define NPY_CPU_M68K
+#elif defined(__arc__) && defined(__LITTLE_ENDIAN__)
+    #define NPY_CPU_ARCEL
+#elif defined(__arc__) && defined(__BIG_ENDIAN__)
+    #define NPY_CPU_ARCEB
+#elif defined(__riscv) && defined(__riscv_xlen) && __riscv_xlen == 64
+    #define NPY_CPU_RISCV64
+#elif defined(__EMSCRIPTEN__)
+    /* __EMSCRIPTEN__ is defined by emscripten: an LLVM-to-Web compiler */
+    #define NPY_CPU_WASM
 #else
     #error Unknown CPU, please report this to numpy maintainers with \
     information about your platform (OS, CPU and compiler)
 #endif
 
-/*
-   This "white-lists" the architectures that we know don't require
-   pointer alignment.  We white-list, since the memcpy version will
-   work everywhere, whereas assignment will only work where pointer
-   dereferencing doesn't require alignment.
+#define NPY_COPY_PYOBJECT_PTR(dst, src) memcpy(dst, src, sizeof(PyObject *))
 
-   TODO: There may be more architectures we can white list.
-*/
-#if defined(NPY_CPU_X86) || defined(NPY_CPU_AMD64)
-    #define NPY_COPY_PYOBJECT_PTR(dst, src) (*((PyObject **)(dst)) = *((PyObject **)(src)))
+#if (defined(NPY_CPU_X86) || defined(NPY_CPU_AMD64))
+#define NPY_CPU_HAVE_UNALIGNED_ACCESS 1
 #else
-    #if NPY_SIZEOF_PY_INTPTR_T == 4
-        #define NPY_COPY_PYOBJECT_PTR(dst, src) \
-            ((char*)(dst))[0] = ((char*)(src))[0]; \
-            ((char*)(dst))[1] = ((char*)(src))[1]; \
-            ((char*)(dst))[2] = ((char*)(src))[2]; \
-            ((char*)(dst))[3] = ((char*)(src))[3];
-    #elif NPY_SIZEOF_PY_INTPTR_T == 8
-        #define NPY_COPY_PYOBJECT_PTR(dst, src) \
-            ((char*)(dst))[0] = ((char*)(src))[0]; \
-            ((char*)(dst))[1] = ((char*)(src))[1]; \
-            ((char*)(dst))[2] = ((char*)(src))[2]; \
-            ((char*)(dst))[3] = ((char*)(src))[3]; \
-            ((char*)(dst))[4] = ((char*)(src))[4]; \
-            ((char*)(dst))[5] = ((char*)(src))[5]; \
-            ((char*)(dst))[6] = ((char*)(src))[6]; \
-            ((char*)(dst))[7] = ((char*)(src))[7];
-    #else
-        #error Unknown architecture, please report this to numpy maintainers with \
-        information about your platform (OS, CPU and compiler)
-    #endif
+#define NPY_CPU_HAVE_UNALIGNED_ACCESS 0
 #endif
 
 #endif
diff --git a/include/numpy/npy_endian.h b/include/numpy/npy_endian.h
index 4e3349ffe..aa367a002 100644
--- a/include/numpy/npy_endian.h
+++ b/include/numpy/npy_endian.h
@@ -6,37 +6,64 @@
  * endian.h
  */
 
-#ifdef NPY_HAVE_ENDIAN_H
+#if defined(NPY_HAVE_ENDIAN_H) || defined(NPY_HAVE_SYS_ENDIAN_H)
     /* Use endian.h if available */
+
+    #if defined(NPY_HAVE_ENDIAN_H)
     #include <endian.h>
+    #elif defined(NPY_HAVE_SYS_ENDIAN_H)
+    #include <sys/endian.h>
+    #endif
+
+    #if defined(BYTE_ORDER) && defined(BIG_ENDIAN) && defined(LITTLE_ENDIAN)
+        #define NPY_BYTE_ORDER    BYTE_ORDER
+        #define NPY_LITTLE_ENDIAN LITTLE_ENDIAN
+        #define NPY_BIG_ENDIAN    BIG_ENDIAN
+    #elif defined(_BYTE_ORDER) && defined(_BIG_ENDIAN) && defined(_LITTLE_ENDIAN)
+        #define NPY_BYTE_ORDER    _BYTE_ORDER
+        #define NPY_LITTLE_ENDIAN _LITTLE_ENDIAN
+        #define NPY_BIG_ENDIAN    _BIG_ENDIAN
+    #elif defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && defined(__LITTLE_ENDIAN)
+        #define NPY_BYTE_ORDER    __BYTE_ORDER
+        #define NPY_LITTLE_ENDIAN __LITTLE_ENDIAN
+        #define NPY_BIG_ENDIAN    __BIG_ENDIAN
+    #endif
+#endif
 
-    #define NPY_BYTE_ORDER __BYTE_ORDER
-    #define NPY_LITTLE_ENDIAN __LITTLE_ENDIAN
-    #define NPY_BIG_ENDIAN __BIG_ENDIAN
-#else
+#ifndef NPY_BYTE_ORDER
     /* Set endianness info using target CPU */
     #include "npy_cpu.h"
 
     #define NPY_LITTLE_ENDIAN 1234
     #define NPY_BIG_ENDIAN 4321
 
-    #if defined(NPY_CPU_X86)            \
-            || defined(NPY_CPU_AMD64)   \
-            || defined(NPY_CPU_IA64)    \
-            || defined(NPY_CPU_ALPHA)   \
-            || defined(NPY_CPU_ARMEL)   \
-            || defined(NPY_CPU_AARCH64) \
-            || defined(NPY_CPU_SH_LE)   \
-            || defined(NPY_CPU_MIPSEL)
+    #if defined(NPY_CPU_X86)                  \
+            || defined(NPY_CPU_AMD64)         \
+            || defined(NPY_CPU_IA64)          \
+            || defined(NPY_CPU_ALPHA)         \
+            || defined(NPY_CPU_ARMEL)         \
+            || defined(NPY_CPU_ARMEL_AARCH32) \
+            || defined(NPY_CPU_ARMEL_AARCH64) \
+            || defined(NPY_CPU_SH_LE)         \
+            || defined(NPY_CPU_MIPSEL)        \
+            || defined(NPY_CPU_PPC64LE)       \
+            || defined(NPY_CPU_ARCEL)         \
+            || defined(NPY_CPU_RISCV64)       \
+            || defined(NPY_CPU_WASM)
         #define NPY_BYTE_ORDER NPY_LITTLE_ENDIAN
-    #elif defined(NPY_CPU_PPC)          \
-            || defined(NPY_CPU_SPARC)   \
-            || defined(NPY_CPU_S390)    \
-            || defined(NPY_CPU_HPPA)    \
-            || defined(NPY_CPU_PPC64)   \
-            || defined(NPY_CPU_ARMEB)   \
-            || defined(NPY_CPU_SH_BE)   \
-            || defined(NPY_CPU_MIPSEB)
+    #elif defined(NPY_CPU_PPC)                \
+            || defined(NPY_CPU_SPARC)         \
+            || defined(NPY_CPU_S390)          \
+            || defined(NPY_CPU_HPPA)          \
+            || defined(NPY_CPU_PPC64)         \
+            || defined(NPY_CPU_ARMEB)         \
+            || defined(NPY_CPU_ARMEB_AARCH32) \
+            || defined(NPY_CPU_ARMEB_AARCH64) \
+            || defined(NPY_CPU_SH_BE)         \
+            || defined(NPY_CPU_MIPSEB)        \
+            || defined(NPY_CPU_OR1K)          \
+            || defined(NPY_CPU_M68K)          \
+            || defined(NPY_CPU_ARCEB)
         #define NPY_BYTE_ORDER NPY_BIG_ENDIAN
     #else
         #error Unknown CPU: can not set endianness
diff --git a/include/numpy/npy_interrupt.h b/include/numpy/npy_interrupt.h
index f71fd689e..bcb539326 100644
--- a/include/numpy/npy_interrupt.h
+++ b/include/numpy/npy_interrupt.h
@@ -1,79 +1,18 @@
-
-/* Signal handling:
-
-This header file defines macros that allow your code to handle
-interrupts received during processing.  Interrupts that
-could reasonably be handled:
-
-SIGINT, SIGABRT, SIGALRM, SIGSEGV
-
-****Warning***************
-
-Do not allow code that creates temporary memory or increases reference
-counts of Python objects to be interrupted unless you handle it
-differently.
-
-**************************
-
-The mechanism for handling interrupts is conceptually simple:
-
-  - replace the signal handler with our own home-grown version
-     and store the old one.
-  - run the code to be interrupted -- if an interrupt occurs
-     the handler should basically just cause a return to the
-     calling function for finish work.
-  - restore the old signal handler
-
-Of course, every code that allows interrupts must account for
-returning via the interrupt and handle clean-up correctly.  But,
-even still, the simple paradigm is complicated by at least three
-factors.
-
- 1) platform portability (i.e. Microsoft says not to use longjmp
-     to return from signal handling.  They have a __try  and __except
-     extension to C instead but what about mingw?).
-
- 2) how to handle threads: apparently whether signals are delivered to
-    every thread of the process or the "invoking" thread is platform
-    dependent. --- we don't handle threads for now.
-
- 3) do we need to worry about re-entrance.  For now, assume the
-    code will not call-back into itself.
-
-Ideas:
-
- 1) Start by implementing an approach that works on platforms that
-    can use setjmp and longjmp functionality and does nothing
-    on other platforms.
-
- 2) Ignore threads --- i.e. do not mix interrupt handling and threads
-
- 3) Add a default signal_handler function to the C-API but have the rest
-    use macros.
-
-
-Simple Interface:
-
-
-In your C-extension: around a block of code you want to be interruptable
-with a SIGINT
-
-NPY_SIGINT_ON
-[code]
-NPY_SIGINT_OFF
-
-In order for this to work correctly, the
-[code] block must not allocate any memory or alter the reference count of any
-Python objects.  In other words [code] must be interruptible so that continuation
-after NPY_SIGINT_OFF will only be "missing some computations"
-
-Interrupt handling does not work well with threads.
-
-*/
-
-/* Add signal handling macros
-   Make the global variable and signal handler part of the C-API
-*/
+/*
+ * This API is only provided because it is part of publicly exported
+ * headers. Its use is considered DEPRECATED, and it will be removed
+ * eventually.
+ * (This includes the _PyArray_SigintHandler and _PyArray_GetSigintBuf
+ * functions which are however, public API, and not headers.)
+ *
+ * Instead of using these non-threadsafe macros consider periodically
+ * querying `PyErr_CheckSignals()` or `PyOS_InterruptOccurred()` will work.
+ * Both of these require holding the GIL, although cpython could add a
+ * version of `PyOS_InterruptOccurred()` which does not. Such a version
+ * actually exists as private API in Python 3.10, and backported to 3.9 and 3.8,
+ * see also https://bugs.python.org/issue41037 and
+ * https://github.com/python/cpython/pull/20599).
+ */
 
 #ifndef NPY_INTERRUPT_H
 #define NPY_INTERRUPT_H
diff --git a/include/numpy/npy_math.h b/include/numpy/npy_math.h
index 7ae166e54..a07f49501 100644
--- a/include/numpy/npy_math.h
+++ b/include/numpy/npy_math.h
@@ -1,12 +1,28 @@
 #ifndef __NPY_MATH_C99_H_
 #define __NPY_MATH_C99_H_
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 #include <math.h>
 #ifdef __SUNPRO_CC
 #include <sunmath.h>
 #endif
+#ifdef HAVE_NPY_CONFIG_H
+#include <npy_config.h>
+#endif
 #include <numpy/npy_common.h>
 
+/* By adding static inline specifiers to npy_math function definitions when
+   appropriate, compiler is given the opportunity to optimize */
+#if NPY_INLINE_MATH
+#define NPY_INPLACE NPY_INLINE static
+#else
+#define NPY_INPLACE
+#endif
+
+
 /*
  * NAN and INFINITY like macros (same behavior as glibc for NAN, same as C99
  * for INFINITY)
@@ -79,7 +95,7 @@ NPY_INLINE static float __npy_nzerof(void)
 #define NPY_PI_4f     0.785398163397448309615660845819875721F /* pi/4 */
 #define NPY_1_PIf     0.318309886183790671537767526745028724F /* 1/pi */
 #define NPY_2_PIf     0.636619772367581343075535053490057448F /* 2/pi */
-#define NPY_EULERf    0.577215664901532860606512090082402431F /* Euler constan*/
+#define NPY_EULERf    0.577215664901532860606512090082402431F /* Euler constant */
 #define NPY_SQRT2f    1.414213562373095048801688724209698079F /* sqrt(2) */
 #define NPY_SQRT1_2f  0.707106781186547524400844362104849039F /* 1/sqrt(2) */
 
@@ -93,87 +109,152 @@ NPY_INLINE static float __npy_nzerof(void)
 #define NPY_PI_4l     0.785398163397448309615660845819875721L /* pi/4 */
 #define NPY_1_PIl     0.318309886183790671537767526745028724L /* 1/pi */
 #define NPY_2_PIl     0.636619772367581343075535053490057448L /* 2/pi */
-#define NPY_EULERl    0.577215664901532860606512090082402431L /* Euler constan*/
+#define NPY_EULERl    0.577215664901532860606512090082402431L /* Euler constant */
 #define NPY_SQRT2l    1.414213562373095048801688724209698079L /* sqrt(2) */
 #define NPY_SQRT1_2l  0.707106781186547524400844362104849039L /* 1/sqrt(2) */
 
+/*
+ * Integer functions.
+ */
+NPY_INPLACE npy_uint npy_gcdu(npy_uint a, npy_uint b);
+NPY_INPLACE npy_uint npy_lcmu(npy_uint a, npy_uint b);
+NPY_INPLACE npy_ulong npy_gcdul(npy_ulong a, npy_ulong b);
+NPY_INPLACE npy_ulong npy_lcmul(npy_ulong a, npy_ulong b);
+NPY_INPLACE npy_ulonglong npy_gcdull(npy_ulonglong a, npy_ulonglong b);
+NPY_INPLACE npy_ulonglong npy_lcmull(npy_ulonglong a, npy_ulonglong b);
+
+NPY_INPLACE npy_int npy_gcd(npy_int a, npy_int b);
+NPY_INPLACE npy_int npy_lcm(npy_int a, npy_int b);
+NPY_INPLACE npy_long npy_gcdl(npy_long a, npy_long b);
+NPY_INPLACE npy_long npy_lcml(npy_long a, npy_long b);
+NPY_INPLACE npy_longlong npy_gcdll(npy_longlong a, npy_longlong b);
+NPY_INPLACE npy_longlong npy_lcmll(npy_longlong a, npy_longlong b);
+
+NPY_INPLACE npy_ubyte npy_rshiftuhh(npy_ubyte a, npy_ubyte b);
+NPY_INPLACE npy_ubyte npy_lshiftuhh(npy_ubyte a, npy_ubyte b);
+NPY_INPLACE npy_ushort npy_rshiftuh(npy_ushort a, npy_ushort b);
+NPY_INPLACE npy_ushort npy_lshiftuh(npy_ushort a, npy_ushort b);
+NPY_INPLACE npy_uint npy_rshiftu(npy_uint a, npy_uint b);
+NPY_INPLACE npy_uint npy_lshiftu(npy_uint a, npy_uint b);
+NPY_INPLACE npy_ulong npy_rshiftul(npy_ulong a, npy_ulong b);
+NPY_INPLACE npy_ulong npy_lshiftul(npy_ulong a, npy_ulong b);
+NPY_INPLACE npy_ulonglong npy_rshiftull(npy_ulonglong a, npy_ulonglong b);
+NPY_INPLACE npy_ulonglong npy_lshiftull(npy_ulonglong a, npy_ulonglong b);
+
+NPY_INPLACE npy_byte npy_rshifthh(npy_byte a, npy_byte b);
+NPY_INPLACE npy_byte npy_lshifthh(npy_byte a, npy_byte b);
+NPY_INPLACE npy_short npy_rshifth(npy_short a, npy_short b);
+NPY_INPLACE npy_short npy_lshifth(npy_short a, npy_short b);
+NPY_INPLACE npy_int npy_rshift(npy_int a, npy_int b);
+NPY_INPLACE npy_int npy_lshift(npy_int a, npy_int b);
+NPY_INPLACE npy_long npy_rshiftl(npy_long a, npy_long b);
+NPY_INPLACE npy_long npy_lshiftl(npy_long a, npy_long b);
+NPY_INPLACE npy_longlong npy_rshiftll(npy_longlong a, npy_longlong b);
+NPY_INPLACE npy_longlong npy_lshiftll(npy_longlong a, npy_longlong b);
+
+/*
+ * avx function has a common API for both sin & cos. This enum is used to
+ * distinguish between the two
+ */
+typedef enum {
+    npy_compute_sin,
+    npy_compute_cos
+} NPY_TRIG_OP;
+
 /*
  * C99 double math funcs
  */
-double npy_sin(double x);
-double npy_cos(double x);
-double npy_tan(double x);
-double npy_sinh(double x);
-double npy_cosh(double x);
-double npy_tanh(double x);
-
-double npy_asin(double x);
-double npy_acos(double x);
-double npy_atan(double x);
-double npy_aexp(double x);
-double npy_alog(double x);
-double npy_asqrt(double x);
-double npy_afabs(double x);
-
-double npy_log(double x);
-double npy_log10(double x);
-double npy_exp(double x);
-double npy_sqrt(double x);
-
-double npy_fabs(double x);
-double npy_ceil(double x);
-double npy_fmod(double x, double y);
-double npy_floor(double x);
-
-double npy_expm1(double x);
-double npy_log1p(double x);
-double npy_hypot(double x, double y);
-double npy_acosh(double x);
-double npy_asinh(double xx);
-double npy_atanh(double x);
-double npy_rint(double x);
-double npy_trunc(double x);
-double npy_exp2(double x);
-double npy_log2(double x);
-
-double npy_atan2(double x, double y);
-double npy_pow(double x, double y);
-double npy_modf(double x, double* y);
-
-double npy_copysign(double x, double y);
+NPY_INPLACE double npy_sin(double x);
+NPY_INPLACE double npy_cos(double x);
+NPY_INPLACE double npy_tan(double x);
+NPY_INPLACE double npy_sinh(double x);
+NPY_INPLACE double npy_cosh(double x);
+NPY_INPLACE double npy_tanh(double x);
+
+NPY_INPLACE double npy_asin(double x);
+NPY_INPLACE double npy_acos(double x);
+NPY_INPLACE double npy_atan(double x);
+
+NPY_INPLACE double npy_log(double x);
+NPY_INPLACE double npy_log10(double x);
+NPY_INPLACE double npy_exp(double x);
+NPY_INPLACE double npy_sqrt(double x);
+NPY_INPLACE double npy_cbrt(double x);
+
+NPY_INPLACE double npy_fabs(double x);
+NPY_INPLACE double npy_ceil(double x);
+NPY_INPLACE double npy_fmod(double x, double y);
+NPY_INPLACE double npy_floor(double x);
+
+NPY_INPLACE double npy_expm1(double x);
+NPY_INPLACE double npy_log1p(double x);
+NPY_INPLACE double npy_hypot(double x, double y);
+NPY_INPLACE double npy_acosh(double x);
+NPY_INPLACE double npy_asinh(double xx);
+NPY_INPLACE double npy_atanh(double x);
+NPY_INPLACE double npy_rint(double x);
+NPY_INPLACE double npy_trunc(double x);
+NPY_INPLACE double npy_exp2(double x);
+NPY_INPLACE double npy_log2(double x);
+
+NPY_INPLACE double npy_atan2(double x, double y);
+NPY_INPLACE double npy_pow(double x, double y);
+NPY_INPLACE double npy_modf(double x, double* y);
+NPY_INPLACE double npy_frexp(double x, int* y);
+NPY_INPLACE double npy_ldexp(double n, int y);
+
+NPY_INPLACE double npy_copysign(double x, double y);
 double npy_nextafter(double x, double y);
 double npy_spacing(double x);
 
 /*
  * IEEE 754 fpu handling. Those are guaranteed to be macros
  */
-#ifndef NPY_HAVE_DECL_ISNAN
-    #define npy_isnan(x) ((x) != (x))
+
+/* use builtins to avoid function calls in tight loops
+ * only available if npy_config.h is available (= numpys own build) */
+#if HAVE___BUILTIN_ISNAN
+    #define npy_isnan(x) __builtin_isnan(x)
 #else
-    #ifdef _MSC_VER
-        #define npy_isnan(x) _isnan((x))
+    #ifndef NPY_HAVE_DECL_ISNAN
+        #define npy_isnan(x) ((x) != (x))
     #else
-        #define npy_isnan(x) isnan((x))
+        #if defined(_MSC_VER) && (_MSC_VER < 1900)
+            #define npy_isnan(x) _isnan((x))
+        #else
+            #define npy_isnan(x) isnan(x)
+        #endif
     #endif
 #endif
 
-#ifndef NPY_HAVE_DECL_ISFINITE
-    #ifdef _MSC_VER
-        #define npy_isfinite(x) _finite((x))
+
+/* only available if npy_config.h is available (= numpys own build) */
+#if HAVE___BUILTIN_ISFINITE
+    #define npy_isfinite(x) __builtin_isfinite(x)
+#else
+    #ifndef NPY_HAVE_DECL_ISFINITE
+        #ifdef _MSC_VER
+            #define npy_isfinite(x) _finite((x))
+        #else
+            #define npy_isfinite(x) !npy_isnan((x) + (-x))
+        #endif
     #else
-        #define npy_isfinite(x) !npy_isnan((x) + (-x))
+        #define npy_isfinite(x) isfinite((x))
     #endif
-#else
-    #define npy_isfinite(x) isfinite((x))
 #endif
 
-#ifndef NPY_HAVE_DECL_ISINF
-    #define npy_isinf(x) (!npy_isfinite(x) && !npy_isnan(x))
+/* only available if npy_config.h is available (= numpys own build) */
+#if HAVE___BUILTIN_ISINF
+    #define npy_isinf(x) __builtin_isinf(x)
 #else
-    #ifdef _MSC_VER
-        #define npy_isinf(x) (!_finite((x)) && !_isnan((x)))
+    #ifndef NPY_HAVE_DECL_ISINF
+        #define npy_isinf(x) (!npy_isfinite(x) && !npy_isnan(x))
     #else
-        #define npy_isinf(x) isinf((x))
+        #if defined(_MSC_VER) && (_MSC_VER < 1900)
+            #define npy_isinf(x) (!_finite((x)) && !_isnan((x)))
+        #else
+            #define npy_isinf(x) isinf((x))
+        #endif
     #endif
 #endif
 
@@ -192,102 +273,113 @@ double npy_spacing(double x);
 /*
  * float C99 math functions
  */
-
-float npy_sinf(float x);
-float npy_cosf(float x);
-float npy_tanf(float x);
-float npy_sinhf(float x);
-float npy_coshf(float x);
-float npy_tanhf(float x);
-float npy_fabsf(float x);
-float npy_floorf(float x);
-float npy_ceilf(float x);
-float npy_rintf(float x);
-float npy_truncf(float x);
-float npy_sqrtf(float x);
-float npy_log10f(float x);
-float npy_logf(float x);
-float npy_expf(float x);
-float npy_expm1f(float x);
-float npy_asinf(float x);
-float npy_acosf(float x);
-float npy_atanf(float x);
-float npy_asinhf(float x);
-float npy_acoshf(float x);
-float npy_atanhf(float x);
-float npy_log1pf(float x);
-float npy_exp2f(float x);
-float npy_log2f(float x);
-
-float npy_atan2f(float x, float y);
-float npy_hypotf(float x, float y);
-float npy_powf(float x, float y);
-float npy_fmodf(float x, float y);
-
-float npy_modff(float x, float* y);
-
-float npy_copysignf(float x, float y);
+NPY_INPLACE float npy_sinf(float x);
+NPY_INPLACE float npy_cosf(float x);
+NPY_INPLACE float npy_tanf(float x);
+NPY_INPLACE float npy_sinhf(float x);
+NPY_INPLACE float npy_coshf(float x);
+NPY_INPLACE float npy_tanhf(float x);
+NPY_INPLACE float npy_fabsf(float x);
+NPY_INPLACE float npy_floorf(float x);
+NPY_INPLACE float npy_ceilf(float x);
+NPY_INPLACE float npy_rintf(float x);
+NPY_INPLACE float npy_truncf(float x);
+NPY_INPLACE float npy_sqrtf(float x);
+NPY_INPLACE float npy_cbrtf(float x);
+NPY_INPLACE float npy_log10f(float x);
+NPY_INPLACE float npy_logf(float x);
+NPY_INPLACE float npy_expf(float x);
+NPY_INPLACE float npy_expm1f(float x);
+NPY_INPLACE float npy_asinf(float x);
+NPY_INPLACE float npy_acosf(float x);
+NPY_INPLACE float npy_atanf(float x);
+NPY_INPLACE float npy_asinhf(float x);
+NPY_INPLACE float npy_acoshf(float x);
+NPY_INPLACE float npy_atanhf(float x);
+NPY_INPLACE float npy_log1pf(float x);
+NPY_INPLACE float npy_exp2f(float x);
+NPY_INPLACE float npy_log2f(float x);
+
+NPY_INPLACE float npy_atan2f(float x, float y);
+NPY_INPLACE float npy_hypotf(float x, float y);
+NPY_INPLACE float npy_powf(float x, float y);
+NPY_INPLACE float npy_fmodf(float x, float y);
+
+NPY_INPLACE float npy_modff(float x, float* y);
+NPY_INPLACE float npy_frexpf(float x, int* y);
+NPY_INPLACE float npy_ldexpf(float x, int y);
+
+NPY_INPLACE float npy_copysignf(float x, float y);
 float npy_nextafterf(float x, float y);
 float npy_spacingf(float x);
 
 /*
- * float C99 math functions
+ * long double C99 math functions
  */
-
-npy_longdouble npy_sinl(npy_longdouble x);
-npy_longdouble npy_cosl(npy_longdouble x);
-npy_longdouble npy_tanl(npy_longdouble x);
-npy_longdouble npy_sinhl(npy_longdouble x);
-npy_longdouble npy_coshl(npy_longdouble x);
-npy_longdouble npy_tanhl(npy_longdouble x);
-npy_longdouble npy_fabsl(npy_longdouble x);
-npy_longdouble npy_floorl(npy_longdouble x);
-npy_longdouble npy_ceill(npy_longdouble x);
-npy_longdouble npy_rintl(npy_longdouble x);
-npy_longdouble npy_truncl(npy_longdouble x);
-npy_longdouble npy_sqrtl(npy_longdouble x);
-npy_longdouble npy_log10l(npy_longdouble x);
-npy_longdouble npy_logl(npy_longdouble x);
-npy_longdouble npy_expl(npy_longdouble x);
-npy_longdouble npy_expm1l(npy_longdouble x);
-npy_longdouble npy_asinl(npy_longdouble x);
-npy_longdouble npy_acosl(npy_longdouble x);
-npy_longdouble npy_atanl(npy_longdouble x);
-npy_longdouble npy_asinhl(npy_longdouble x);
-npy_longdouble npy_acoshl(npy_longdouble x);
-npy_longdouble npy_atanhl(npy_longdouble x);
-npy_longdouble npy_log1pl(npy_longdouble x);
-npy_longdouble npy_exp2l(npy_longdouble x);
-npy_longdouble npy_log2l(npy_longdouble x);
-
-npy_longdouble npy_atan2l(npy_longdouble x, npy_longdouble y);
-npy_longdouble npy_hypotl(npy_longdouble x, npy_longdouble y);
-npy_longdouble npy_powl(npy_longdouble x, npy_longdouble y);
-npy_longdouble npy_fmodl(npy_longdouble x, npy_longdouble y);
-
-npy_longdouble npy_modfl(npy_longdouble x, npy_longdouble* y);
-
-npy_longdouble npy_copysignl(npy_longdouble x, npy_longdouble y);
+NPY_INPLACE npy_longdouble npy_sinl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_cosl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_tanl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_sinhl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_coshl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_tanhl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_fabsl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_floorl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_ceill(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_rintl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_truncl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_sqrtl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_cbrtl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_log10l(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_logl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_expl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_expm1l(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_asinl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_acosl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_atanl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_asinhl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_acoshl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_atanhl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_log1pl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_exp2l(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_log2l(npy_longdouble x);
+
+NPY_INPLACE npy_longdouble npy_atan2l(npy_longdouble x, npy_longdouble y);
+NPY_INPLACE npy_longdouble npy_hypotl(npy_longdouble x, npy_longdouble y);
+NPY_INPLACE npy_longdouble npy_powl(npy_longdouble x, npy_longdouble y);
+NPY_INPLACE npy_longdouble npy_fmodl(npy_longdouble x, npy_longdouble y);
+
+NPY_INPLACE npy_longdouble npy_modfl(npy_longdouble x, npy_longdouble* y);
+NPY_INPLACE npy_longdouble npy_frexpl(npy_longdouble x, int* y);
+NPY_INPLACE npy_longdouble npy_ldexpl(npy_longdouble x, int y);
+
+NPY_INPLACE npy_longdouble npy_copysignl(npy_longdouble x, npy_longdouble y);
 npy_longdouble npy_nextafterl(npy_longdouble x, npy_longdouble y);
 npy_longdouble npy_spacingl(npy_longdouble x);
 
 /*
  * Non standard functions
  */
-double npy_deg2rad(double x);
-double npy_rad2deg(double x);
-double npy_logaddexp(double x, double y);
-double npy_logaddexp2(double x, double y);
-
-float npy_deg2radf(float x);
-float npy_rad2degf(float x);
-float npy_logaddexpf(float x, float y);
-float npy_logaddexp2f(float x, float y);
-
-npy_longdouble npy_deg2radl(npy_longdouble x);
-npy_longdouble npy_rad2degl(npy_longdouble x);
-npy_longdouble npy_logaddexpl(npy_longdouble x, npy_longdouble y);
-npy_longdouble npy_logaddexp2l(npy_longdouble x, npy_longdouble y);
+NPY_INPLACE double npy_deg2rad(double x);
+NPY_INPLACE double npy_rad2deg(double x);
+NPY_INPLACE double npy_logaddexp(double x, double y);
+NPY_INPLACE double npy_logaddexp2(double x, double y);
+NPY_INPLACE double npy_divmod(double x, double y, double *modulus);
+NPY_INPLACE double npy_heaviside(double x, double h0);
+
+NPY_INPLACE float npy_deg2radf(float x);
+NPY_INPLACE float npy_rad2degf(float x);
+NPY_INPLACE float npy_logaddexpf(float x, float y);
+NPY_INPLACE float npy_logaddexp2f(float x, float y);
+NPY_INPLACE float npy_divmodf(float x, float y, float *modulus);
+NPY_INPLACE float npy_heavisidef(float x, float h0);
+
+NPY_INPLACE npy_longdouble npy_deg2radl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_rad2degl(npy_longdouble x);
+NPY_INPLACE npy_longdouble npy_logaddexpl(npy_longdouble x, npy_longdouble y);
+NPY_INPLACE npy_longdouble npy_logaddexp2l(npy_longdouble x, npy_longdouble y);
+NPY_INPLACE npy_longdouble npy_divmodl(npy_longdouble x, npy_longdouble y,
+                           npy_longdouble *modulus);
+NPY_INPLACE npy_longdouble npy_heavisidel(npy_longdouble x, npy_longdouble h0);
 
 #define npy_degrees npy_rad2deg
 #define npy_degreesf npy_rad2degf
@@ -394,6 +486,19 @@ npy_cdouble npy_csqrt(npy_cdouble z);
 
 npy_cdouble npy_ccos(npy_cdouble z);
 npy_cdouble npy_csin(npy_cdouble z);
+npy_cdouble npy_ctan(npy_cdouble z);
+
+npy_cdouble npy_ccosh(npy_cdouble z);
+npy_cdouble npy_csinh(npy_cdouble z);
+npy_cdouble npy_ctanh(npy_cdouble z);
+
+npy_cdouble npy_cacos(npy_cdouble z);
+npy_cdouble npy_casin(npy_cdouble z);
+npy_cdouble npy_catan(npy_cdouble z);
+
+npy_cdouble npy_cacosh(npy_cdouble z);
+npy_cdouble npy_casinh(npy_cdouble z);
+npy_cdouble npy_catanh(npy_cdouble z);
 
 /*
  * Single precision complex functions
@@ -409,6 +514,20 @@ npy_cfloat npy_csqrtf(npy_cfloat z);
 
 npy_cfloat npy_ccosf(npy_cfloat z);
 npy_cfloat npy_csinf(npy_cfloat z);
+npy_cfloat npy_ctanf(npy_cfloat z);
+
+npy_cfloat npy_ccoshf(npy_cfloat z);
+npy_cfloat npy_csinhf(npy_cfloat z);
+npy_cfloat npy_ctanhf(npy_cfloat z);
+
+npy_cfloat npy_cacosf(npy_cfloat z);
+npy_cfloat npy_casinf(npy_cfloat z);
+npy_cfloat npy_catanf(npy_cfloat z);
+
+npy_cfloat npy_cacoshf(npy_cfloat z);
+npy_cfloat npy_casinhf(npy_cfloat z);
+npy_cfloat npy_catanhf(npy_cfloat z);
+
 
 /*
  * Extended precision complex functions
@@ -424,15 +543,57 @@ npy_clongdouble npy_csqrtl(npy_clongdouble z);
 
 npy_clongdouble npy_ccosl(npy_clongdouble z);
 npy_clongdouble npy_csinl(npy_clongdouble z);
+npy_clongdouble npy_ctanl(npy_clongdouble z);
+
+npy_clongdouble npy_ccoshl(npy_clongdouble z);
+npy_clongdouble npy_csinhl(npy_clongdouble z);
+npy_clongdouble npy_ctanhl(npy_clongdouble z);
+
+npy_clongdouble npy_cacosl(npy_clongdouble z);
+npy_clongdouble npy_casinl(npy_clongdouble z);
+npy_clongdouble npy_catanl(npy_clongdouble z);
+
+npy_clongdouble npy_cacoshl(npy_clongdouble z);
+npy_clongdouble npy_casinhl(npy_clongdouble z);
+npy_clongdouble npy_catanhl(npy_clongdouble z);
+
 
 /*
  * Functions that set the floating point error
  * status word.
  */
 
+/*
+ * platform-dependent code translates floating point
+ * status to an integer sum of these values
+ */
+#define NPY_FPE_DIVIDEBYZERO  1
+#define NPY_FPE_OVERFLOW      2
+#define NPY_FPE_UNDERFLOW     4
+#define NPY_FPE_INVALID       8
+
+int npy_clear_floatstatus_barrier(char*);
+int npy_get_floatstatus_barrier(char*);
+/*
+ * use caution with these - clang and gcc8.1 are known to reorder calls
+ * to this form of the function which can defeat the check. The _barrier
+ * form of the call is preferable, where the argument is
+ * (char*)&local_variable
+ */
+int npy_clear_floatstatus(void);
+int npy_get_floatstatus(void);
+
 void npy_set_floatstatus_divbyzero(void);
 void npy_set_floatstatus_overflow(void);
 void npy_set_floatstatus_underflow(void);
 void npy_set_floatstatus_invalid(void);
 
+#ifdef __cplusplus
+}
+#endif
+
+#if NPY_INLINE_MATH
+#include "npy_math_internal.h"
+#endif
+
 #endif
diff --git a/include/numpy/numpyconfig.h b/include/numpy/numpyconfig.h
index 401d19fd7..4df4ea438 100644
--- a/include/numpy/numpyconfig.h
+++ b/include/numpy/numpyconfig.h
@@ -6,19 +6,19 @@
 /*
  * On Mac OS X, because there is only one configuration stage for all the archs
  * in universal builds, any macro which depends on the arch needs to be
- * harcoded
+ * hardcoded
  */
 #ifdef __APPLE__
-	#undef NPY_SIZEOF_LONG
-	#undef NPY_SIZEOF_PY_INTPTR_T
+    #undef NPY_SIZEOF_LONG
+    #undef NPY_SIZEOF_PY_INTPTR_T
 
-	#ifdef __LP64__
-		#define NPY_SIZEOF_LONG 		8
-		#define NPY_SIZEOF_PY_INTPTR_T 	8
-	#else
-		#define NPY_SIZEOF_LONG 		4
-		#define NPY_SIZEOF_PY_INTPTR_T 	4
-	#endif
+    #ifdef __LP64__
+        #define NPY_SIZEOF_LONG         8
+        #define NPY_SIZEOF_PY_INTPTR_T  8
+    #else
+        #define NPY_SIZEOF_LONG         4
+        #define NPY_SIZEOF_PY_INTPTR_T  4
+    #endif
 #endif
 
 /**
@@ -29,5 +29,17 @@
  *   #define NPY_NO_DEPRECATED_API  NPY_1_7_API_VERSION
  */
 #define NPY_1_7_API_VERSION 0x00000007
+#define NPY_1_8_API_VERSION 0x00000008
+#define NPY_1_9_API_VERSION 0x00000008
+#define NPY_1_10_API_VERSION 0x00000008
+#define NPY_1_11_API_VERSION 0x00000008
+#define NPY_1_12_API_VERSION 0x00000008
+#define NPY_1_13_API_VERSION 0x00000008
+#define NPY_1_14_API_VERSION 0x00000008
+#define NPY_1_15_API_VERSION 0x00000008
+#define NPY_1_16_API_VERSION 0x00000008
+#define NPY_1_17_API_VERSION 0x00000008
+#define NPY_1_18_API_VERSION 0x00000008
+#define NPY_1_19_API_VERSION 0x00000008
 
 #endif
diff --git a/include/numpy/oldnumeric.h b/include/numpy/oldnumeric.h
index 748f06da3..38530faf0 100644
--- a/include/numpy/oldnumeric.h
+++ b/include/numpy/oldnumeric.h
@@ -1,9 +1,11 @@
 #include "arrayobject.h"
 
+#ifndef PYPY_VERSION
 #ifndef REFCOUNT
 #  define REFCOUNT NPY_REFCOUNT
 #  define MAX_ELSIZE 16
 #endif
+#endif
 
 #define PyArray_UNSIGNED_TYPES
 #define PyArray_SBYTE NPY_BYTE
diff --git a/include/numpy/random/bitgen.h b/include/numpy/random/bitgen.h
new file mode 100644
index 000000000..83c2858dd
--- /dev/null
+++ b/include/numpy/random/bitgen.h
@@ -0,0 +1,20 @@
+#ifndef _RANDOM_BITGEN_H
+#define _RANDOM_BITGEN_H
+
+#pragma once
+#include <stddef.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+/* Must match the declaration in numpy/random/<any>.pxd */
+
+typedef struct bitgen {
+  void *state;
+  uint64_t (*next_uint64)(void *st);
+  uint32_t (*next_uint32)(void *st);
+  double (*next_double)(void *st);
+  uint64_t (*next_raw)(void *st);
+} bitgen_t;
+
+
+#endif
diff --git a/include/numpy/random/distributions.h b/include/numpy/random/distributions.h
new file mode 100644
index 000000000..c474c4d14
--- /dev/null
+++ b/include/numpy/random/distributions.h
@@ -0,0 +1,200 @@
+#ifndef _RANDOMDGEN__DISTRIBUTIONS_H_
+#define _RANDOMDGEN__DISTRIBUTIONS_H_
+
+#include "Python.h"
+#include "numpy/npy_common.h"
+#include <stddef.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "numpy/npy_math.h"
+#include "numpy/random/bitgen.h"
+
+/*
+ * RAND_INT_TYPE is used to share integer generators with RandomState which
+ * used long in place of int64_t. If changing a distribution that uses
+ * RAND_INT_TYPE, then the original unmodified copy must be retained for
+ * use in RandomState by copying to the legacy distributions source file.
+ */
+#ifdef NP_RANDOM_LEGACY
+#define RAND_INT_TYPE long
+#define RAND_INT_MAX LONG_MAX
+#else
+#define RAND_INT_TYPE int64_t
+#define RAND_INT_MAX INT64_MAX
+#endif
+
+#ifdef _MSC_VER
+#define DECLDIR __declspec(dllexport)
+#else
+#define DECLDIR extern
+#endif
+
+#ifndef MIN
+#define MIN(x, y) (((x) < (y)) ? x : y)
+#define MAX(x, y) (((x) > (y)) ? x : y)
+#endif
+
+#ifndef M_PI
+#define M_PI 3.14159265358979323846264338328
+#endif
+
+typedef struct s_binomial_t {
+  int has_binomial; /* !=0: following parameters initialized for binomial */
+  double psave;
+  RAND_INT_TYPE nsave;
+  double r;
+  double q;
+  double fm;
+  RAND_INT_TYPE m;
+  double p1;
+  double xm;
+  double xl;
+  double xr;
+  double c;
+  double laml;
+  double lamr;
+  double p2;
+  double p3;
+  double p4;
+} binomial_t;
+
+DECLDIR float random_standard_uniform_f(bitgen_t *bitgen_state);
+DECLDIR double random_standard_uniform(bitgen_t *bitgen_state);
+DECLDIR void random_standard_uniform_fill(bitgen_t *, npy_intp, double *);
+DECLDIR void random_standard_uniform_fill_f(bitgen_t *, npy_intp, float *);
+
+DECLDIR int64_t random_positive_int64(bitgen_t *bitgen_state);
+DECLDIR int32_t random_positive_int32(bitgen_t *bitgen_state);
+DECLDIR int64_t random_positive_int(bitgen_t *bitgen_state);
+DECLDIR uint64_t random_uint(bitgen_t *bitgen_state);
+
+DECLDIR double random_standard_exponential(bitgen_t *bitgen_state);
+DECLDIR float random_standard_exponential_f(bitgen_t *bitgen_state);
+DECLDIR void random_standard_exponential_fill(bitgen_t *, npy_intp, double *);
+DECLDIR void random_standard_exponential_fill_f(bitgen_t *, npy_intp, float *);
+DECLDIR void random_standard_exponential_inv_fill(bitgen_t *, npy_intp, double *);
+DECLDIR void random_standard_exponential_inv_fill_f(bitgen_t *, npy_intp, float *);
+
+DECLDIR double random_standard_normal(bitgen_t *bitgen_state);
+DECLDIR float random_standard_normal_f(bitgen_t *bitgen_state);
+DECLDIR void random_standard_normal_fill(bitgen_t *, npy_intp, double *);
+DECLDIR void random_standard_normal_fill_f(bitgen_t *, npy_intp, float *);
+DECLDIR double random_standard_gamma(bitgen_t *bitgen_state, double shape);
+DECLDIR float random_standard_gamma_f(bitgen_t *bitgen_state, float shape);
+
+DECLDIR double random_normal(bitgen_t *bitgen_state, double loc, double scale);
+
+DECLDIR double random_gamma(bitgen_t *bitgen_state, double shape, double scale);
+DECLDIR float random_gamma_f(bitgen_t *bitgen_state, float shape, float scale);
+
+DECLDIR double random_exponential(bitgen_t *bitgen_state, double scale);
+DECLDIR double random_uniform(bitgen_t *bitgen_state, double lower, double range);
+DECLDIR double random_beta(bitgen_t *bitgen_state, double a, double b);
+DECLDIR double random_chisquare(bitgen_t *bitgen_state, double df);
+DECLDIR double random_f(bitgen_t *bitgen_state, double dfnum, double dfden);
+DECLDIR double random_standard_cauchy(bitgen_t *bitgen_state);
+DECLDIR double random_pareto(bitgen_t *bitgen_state, double a);
+DECLDIR double random_weibull(bitgen_t *bitgen_state, double a);
+DECLDIR double random_power(bitgen_t *bitgen_state, double a);
+DECLDIR double random_laplace(bitgen_t *bitgen_state, double loc, double scale);
+DECLDIR double random_gumbel(bitgen_t *bitgen_state, double loc, double scale);
+DECLDIR double random_logistic(bitgen_t *bitgen_state, double loc, double scale);
+DECLDIR double random_lognormal(bitgen_t *bitgen_state, double mean, double sigma);
+DECLDIR double random_rayleigh(bitgen_t *bitgen_state, double mode);
+DECLDIR double random_standard_t(bitgen_t *bitgen_state, double df);
+DECLDIR double random_noncentral_chisquare(bitgen_t *bitgen_state, double df,
+                                           double nonc);
+DECLDIR double random_noncentral_f(bitgen_t *bitgen_state, double dfnum,
+                                   double dfden, double nonc);
+DECLDIR double random_wald(bitgen_t *bitgen_state, double mean, double scale);
+DECLDIR double random_vonmises(bitgen_t *bitgen_state, double mu, double kappa);
+DECLDIR double random_triangular(bitgen_t *bitgen_state, double left, double mode,
+                                 double right);
+
+DECLDIR RAND_INT_TYPE random_poisson(bitgen_t *bitgen_state, double lam);
+DECLDIR RAND_INT_TYPE random_negative_binomial(bitgen_t *bitgen_state, double n,
+                                 double p);
+
+DECLDIR int64_t random_binomial(bitgen_t *bitgen_state, double p,
+                                int64_t n, binomial_t *binomial);
+
+DECLDIR RAND_INT_TYPE random_logseries(bitgen_t *bitgen_state, double p);
+DECLDIR RAND_INT_TYPE random_geometric(bitgen_t *bitgen_state, double p);
+DECLDIR RAND_INT_TYPE random_zipf(bitgen_t *bitgen_state, double a);
+DECLDIR int64_t random_hypergeometric(bitgen_t *bitgen_state,
+                                      int64_t good, int64_t bad, int64_t sample);
+DECLDIR uint64_t random_interval(bitgen_t *bitgen_state, uint64_t max);
+
+/* Generate random uint64 numbers in closed interval [off, off + rng]. */
+DECLDIR uint64_t random_bounded_uint64(bitgen_t *bitgen_state, uint64_t off,
+                                       uint64_t rng, uint64_t mask,
+                                       bool use_masked);
+
+/* Generate random uint32 numbers in closed interval [off, off + rng]. */
+DECLDIR uint32_t random_buffered_bounded_uint32(bitgen_t *bitgen_state,
+                                                uint32_t off, uint32_t rng,
+                                                uint32_t mask, bool use_masked,
+                                                int *bcnt, uint32_t *buf);
+DECLDIR uint16_t random_buffered_bounded_uint16(bitgen_t *bitgen_state,
+                                                uint16_t off, uint16_t rng,
+                                                uint16_t mask, bool use_masked,
+                                                int *bcnt, uint32_t *buf);
+DECLDIR uint8_t random_buffered_bounded_uint8(bitgen_t *bitgen_state, uint8_t off,
+                                              uint8_t rng, uint8_t mask,
+                                              bool use_masked, int *bcnt,
+                                              uint32_t *buf);
+DECLDIR npy_bool random_buffered_bounded_bool(bitgen_t *bitgen_state, npy_bool off,
+                                              npy_bool rng, npy_bool mask,
+                                              bool use_masked, int *bcnt,
+                                              uint32_t *buf);
+
+DECLDIR void random_bounded_uint64_fill(bitgen_t *bitgen_state, uint64_t off,
+                                        uint64_t rng, npy_intp cnt,
+                                        bool use_masked, uint64_t *out);
+DECLDIR void random_bounded_uint32_fill(bitgen_t *bitgen_state, uint32_t off,
+                                        uint32_t rng, npy_intp cnt,
+                                        bool use_masked, uint32_t *out);
+DECLDIR void random_bounded_uint16_fill(bitgen_t *bitgen_state, uint16_t off,
+                                        uint16_t rng, npy_intp cnt,
+                                        bool use_masked, uint16_t *out);
+DECLDIR void random_bounded_uint8_fill(bitgen_t *bitgen_state, uint8_t off,
+                                       uint8_t rng, npy_intp cnt,
+                                       bool use_masked, uint8_t *out);
+DECLDIR void random_bounded_bool_fill(bitgen_t *bitgen_state, npy_bool off,
+                                      npy_bool rng, npy_intp cnt,
+                                      bool use_masked, npy_bool *out);
+
+DECLDIR void random_multinomial(bitgen_t *bitgen_state, RAND_INT_TYPE n, RAND_INT_TYPE *mnix,
+                                double *pix, npy_intp d, binomial_t *binomial);
+
+/* multivariate hypergeometric, "count" method */
+DECLDIR int random_multivariate_hypergeometric_count(bitgen_t *bitgen_state,
+                              int64_t total,
+                              size_t num_colors, int64_t *colors,
+                              int64_t nsample,
+                              size_t num_variates, int64_t *variates);
+
+/* multivariate hypergeometric, "marginals" method */
+DECLDIR void random_multivariate_hypergeometric_marginals(bitgen_t *bitgen_state,
+                                   int64_t total,
+                                   size_t num_colors, int64_t *colors,
+                                   int64_t nsample,
+                                   size_t num_variates, int64_t *variates);
+
+/* Common to legacy-distributions.c and distributions.c but not exported */
+
+RAND_INT_TYPE random_binomial_btpe(bitgen_t *bitgen_state,
+                                   RAND_INT_TYPE n,
+                                   double p,
+                                   binomial_t *binomial);
+RAND_INT_TYPE random_binomial_inversion(bitgen_t *bitgen_state,
+                                        RAND_INT_TYPE n,
+                                        double p,
+                                        binomial_t *binomial);
+double random_loggam(double x);
+static NPY_INLINE double next_double(bitgen_t *bitgen_state) {
+    return bitgen_state->next_double(bitgen_state->state);
+}
+
+#endif
diff --git a/include/numpy/ufunc_api.txt b/include/numpy/ufunc_api.txt
index 3365433cd..386848c30 100644
--- a/include/numpy/ufunc_api.txt
+++ b/include/numpy/ufunc_api.txt
@@ -1,14 +1,14 @@
 
 =================
-Numpy Ufunc C-API
+NumPy Ufunc C-API
 =================
 ::
 
   PyObject *
   PyUFunc_FromFuncAndData(PyUFuncGenericFunction *func, void
                           **data, char *types, int ntypes, int nin, int
-                          nout, int identity, char *name, char *doc, int
-                          check_return)
+                          nout, int identity, const char *name, const
+                          char *doc, int unused)
 
 
 ::
@@ -16,7 +16,8 @@ Numpy Ufunc C-API
   int
   PyUFunc_RegisterLoopForType(PyUFuncObject *ufunc, int
                               usertype, PyUFuncGenericFunction
-                              function, int *arg_types, void *data)
+                              function, const int *arg_types, void
+                              *data)
 
 
 ::
@@ -26,156 +27,151 @@ Numpy Ufunc C-API
                           *kwds, PyArrayObject **op)
 
 
-This generic function is called with the ufunc object, the arguments to it,
-and an array of (pointers to) PyArrayObjects which are NULL.
-
-'op' is an array of at least NPY_MAXARGS PyArrayObject *.
-
 ::
 
   void
-  PyUFunc_f_f_As_d_d(char **args, npy_intp *dimensions, npy_intp
-                     *steps, void *func)
+  PyUFunc_f_f_As_d_d(char **args, npy_intp const *dimensions, npy_intp
+                     const *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_d_d(char **args, npy_intp *dimensions, npy_intp *steps, void
-              *func)
+  PyUFunc_d_d(char **args, npy_intp const *dimensions, npy_intp const
+              *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_f_f(char **args, npy_intp *dimensions, npy_intp *steps, void
-              *func)
+  PyUFunc_f_f(char **args, npy_intp const *dimensions, npy_intp const
+              *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_g_g(char **args, npy_intp *dimensions, npy_intp *steps, void
-              *func)
+  PyUFunc_g_g(char **args, npy_intp const *dimensions, npy_intp const
+              *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_F_F_As_D_D(char **args, npy_intp *dimensions, npy_intp
-                     *steps, void *func)
+  PyUFunc_F_F_As_D_D(char **args, npy_intp const *dimensions, npy_intp
+                     const *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_F_F(char **args, npy_intp *dimensions, npy_intp *steps, void
-              *func)
+  PyUFunc_F_F(char **args, npy_intp const *dimensions, npy_intp const
+              *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_D_D(char **args, npy_intp *dimensions, npy_intp *steps, void
-              *func)
+  PyUFunc_D_D(char **args, npy_intp const *dimensions, npy_intp const
+              *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_G_G(char **args, npy_intp *dimensions, npy_intp *steps, void
-              *func)
+  PyUFunc_G_G(char **args, npy_intp const *dimensions, npy_intp const
+              *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_O_O(char **args, npy_intp *dimensions, npy_intp *steps, void
-              *func)
+  PyUFunc_O_O(char **args, npy_intp const *dimensions, npy_intp const
+              *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_ff_f_As_dd_d(char **args, npy_intp *dimensions, npy_intp
-                       *steps, void *func)
+  PyUFunc_ff_f_As_dd_d(char **args, npy_intp const *dimensions, npy_intp
+                       const *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_ff_f(char **args, npy_intp *dimensions, npy_intp *steps, void
-               *func)
+  PyUFunc_ff_f(char **args, npy_intp const *dimensions, npy_intp const
+               *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_dd_d(char **args, npy_intp *dimensions, npy_intp *steps, void
-               *func)
+  PyUFunc_dd_d(char **args, npy_intp const *dimensions, npy_intp const
+               *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_gg_g(char **args, npy_intp *dimensions, npy_intp *steps, void
-               *func)
+  PyUFunc_gg_g(char **args, npy_intp const *dimensions, npy_intp const
+               *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_FF_F_As_DD_D(char **args, npy_intp *dimensions, npy_intp
-                       *steps, void *func)
+  PyUFunc_FF_F_As_DD_D(char **args, npy_intp const *dimensions, npy_intp
+                       const *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_DD_D(char **args, npy_intp *dimensions, npy_intp *steps, void
-               *func)
+  PyUFunc_DD_D(char **args, npy_intp const *dimensions, npy_intp const
+               *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_FF_F(char **args, npy_intp *dimensions, npy_intp *steps, void
-               *func)
+  PyUFunc_FF_F(char **args, npy_intp const *dimensions, npy_intp const
+               *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_GG_G(char **args, npy_intp *dimensions, npy_intp *steps, void
-               *func)
+  PyUFunc_GG_G(char **args, npy_intp const *dimensions, npy_intp const
+               *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_OO_O(char **args, npy_intp *dimensions, npy_intp *steps, void
-               *func)
+  PyUFunc_OO_O(char **args, npy_intp const *dimensions, npy_intp const
+               *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_O_O_method(char **args, npy_intp *dimensions, npy_intp
-                     *steps, void *func)
+  PyUFunc_O_O_method(char **args, npy_intp const *dimensions, npy_intp
+                     const *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_OO_O_method(char **args, npy_intp *dimensions, npy_intp
-                      *steps, void *func)
+  PyUFunc_OO_O_method(char **args, npy_intp const *dimensions, npy_intp
+                      const *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_On_Om(char **args, npy_intp *dimensions, npy_intp *steps, void
-                *func)
+  PyUFunc_On_Om(char **args, npy_intp const *dimensions, npy_intp const
+                *steps, void *func)
 
 
 ::
@@ -218,7 +214,7 @@ owns a new reference to errobj.
   int
   PyUFunc_ReplaceLoopBySignature(PyUFuncObject
                                  *func, PyUFuncGenericFunction
-                                 newfunc, int
+                                 newfunc, const int
                                  *signature, PyUFuncGenericFunction
                                  *oldfunc)
 
@@ -229,8 +225,8 @@ owns a new reference to errobj.
   PyUFunc_FromFuncAndDataAndSignature(PyUFuncGenericFunction *func, void
                                       **data, char *types, int
                                       ntypes, int nin, int nout, int
-                                      identity, char *name, char
-                                      *doc, int check_return, const char
+                                      identity, const char *name, const
+                                      char *doc, int unused, const char
                                       *signature)
 
 
@@ -243,43 +239,43 @@ owns a new reference to errobj.
 ::
 
   void
-  PyUFunc_e_e(char **args, npy_intp *dimensions, npy_intp *steps, void
-              *func)
+  PyUFunc_e_e(char **args, npy_intp const *dimensions, npy_intp const
+              *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_e_e_As_f_f(char **args, npy_intp *dimensions, npy_intp
-                     *steps, void *func)
+  PyUFunc_e_e_As_f_f(char **args, npy_intp const *dimensions, npy_intp
+                     const *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_e_e_As_d_d(char **args, npy_intp *dimensions, npy_intp
-                     *steps, void *func)
+  PyUFunc_e_e_As_d_d(char **args, npy_intp const *dimensions, npy_intp
+                     const *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_ee_e(char **args, npy_intp *dimensions, npy_intp *steps, void
-               *func)
+  PyUFunc_ee_e(char **args, npy_intp const *dimensions, npy_intp const
+               *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_ee_e_As_ff_f(char **args, npy_intp *dimensions, npy_intp
-                       *steps, void *func)
+  PyUFunc_ee_e_As_ff_f(char **args, npy_intp const *dimensions, npy_intp
+                       const *steps, void *func)
 
 
 ::
 
   void
-  PyUFunc_ee_e_As_dd_d(char **args, npy_intp *dimensions, npy_intp
-                       *steps, void *func)
+  PyUFunc_ee_e_As_dd_d(char **args, npy_intp const *dimensions, npy_intp
+                       const *steps, void *func)
 
 
 ::
@@ -310,3 +306,28 @@ the output operands where provided.
 
 Returns 0 on success, -1 (with exception raised) on validation failure.
 
+::
+
+  int
+  PyUFunc_RegisterLoopForDescr(PyUFuncObject *ufunc, PyArray_Descr
+                               *user_dtype, PyUFuncGenericFunction
+                               function, PyArray_Descr
+                               **arg_dtypes, void *data)
+
+
+::
+
+  PyObject *
+  PyUFunc_FromFuncAndDataAndSignatureAndIdentity(PyUFuncGenericFunction
+                                                 *func, void
+                                                 **data, char
+                                                 *types, int ntypes, int
+                                                 nin, int nout, int
+                                                 identity, const char
+                                                 *name, const char
+                                                 *doc, const int
+                                                 unused, const char
+                                                 *signature, PyObject
+                                                 *identity_value)
+
+
diff --git a/include/numpy/ufuncobject.h b/include/numpy/ufuncobject.h
index 95afd5aa2..e5d845842 100644
--- a/include/numpy/ufuncobject.h
+++ b/include/numpy/ufuncobject.h
@@ -2,6 +2,7 @@
 #define Py_UFUNCOBJECT_H
 
 #include <numpy/npy_math.h>
+#include <numpy/npy_common.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -13,21 +14,10 @@ extern "C" {
  */
 typedef void (*PyUFuncGenericFunction)
             (char **args,
-             npy_intp *dimensions,
-             npy_intp *strides,
+             npy_intp const *dimensions,
+             npy_intp const *strides,
              void *innerloopdata);
 
-/*
- * The most generic one-dimensional inner loop for
- * a standard element-wise ufunc. This typedef is also
- * more consistent with the other NumPy function pointer typedefs
- * than PyUFuncGenericFunction.
- */
-typedef void (PyUFunc_StridedInnerLoopFunc)(
-                char **dataptrs, npy_intp *strides,
-                npy_intp count,
-                NpyAuxData *innerloopdata);
-
 /*
  * The most generic one-dimensional inner loop for
  * a masked standard element-wise ufunc. "Masked" here means that it skips
@@ -88,7 +78,7 @@ typedef int (PyUFunc_TypeResolutionFunc)(
  *
  * ufunc:             The ufunc object.
  * dtypes:            An array which has been populated with dtypes,
- *                    in most cases by the type resolution funciton
+ *                    in most cases by the type resolution function
  *                    for the same ufunc.
  * fixed_strides:     For each input/output, either the stride that
  *                    will be used every time the function is called
@@ -111,13 +101,6 @@ typedef int (PyUFunc_LegacyInnerLoopSelectionFunc)(
                             PyUFuncGenericFunction *out_innerloop,
                             void **out_innerloopdata,
                             int *out_needs_api);
-typedef int (PyUFunc_InnerLoopSelectionFunc)(
-                            struct _tagPyUFuncObject *ufunc,
-                            PyArray_Descr **dtypes,
-                            npy_intp *fixed_strides,
-                            PyUFunc_StridedInnerLoopFunc **out_innerloop,
-                            NpyAuxData **out_innerloopdata,
-                            int *out_needs_api);
 typedef int (PyUFunc_MaskedInnerLoopSelectionFunc)(
                             struct _tagPyUFuncObject *ufunc,
                             PyArray_Descr **dtypes,
@@ -137,7 +120,11 @@ typedef struct _tagPyUFuncObject {
          */
         int nin, nout, nargs;
 
-        /* Identity for reduction, either PyUFunc_One or PyUFunc_Zero */
+        /*
+         * Identity for reduction, any of PyUFunc_One, PyUFunc_Zero
+         * PyUFunc_MinusOne, PyUFunc_None, PyUFunc_ReorderableNone,
+         * PyUFunc_IdentityValue.
+         */
         int identity;
 
         /* Array of one-dimensional core loops */
@@ -147,17 +134,17 @@ typedef struct _tagPyUFuncObject {
         /* The number of elements in 'functions' and 'data' */
         int ntypes;
 
-        /* Does not appear to be used */
-        int check_return;
+        /* Used to be unused field 'check_return' */
+        int reserved1;
 
         /* The name of the ufunc */
-        char *name;
+        const char *name;
 
         /* Array of type numbers, of size ('nargs' * 'ntypes') */
         char *types;
 
         /* Documentation string */
-        char *doc;
+        const char *doc;
 
         void *ptr;
         PyObject *obj;
@@ -184,7 +171,7 @@ typedef struct _tagPyUFuncObject {
         int *core_dim_ixs;
         /*
          * positions of 1st core dimensions of each
-         * argument in core_dim_ixs
+         * argument in core_dim_ixs, equivalent to cumsum(core_num_dims)
          */
         int *core_offsets;
         /* signature string for printing purpose */
@@ -203,18 +190,56 @@ typedef struct _tagPyUFuncObject {
          */
         PyUFunc_LegacyInnerLoopSelectionFunc *legacy_inner_loop_selector;
         /*
-         * A function which returns an inner loop for the new mechanism
-         * in NumPy 1.7 and later. If provided, this is used, otherwise
-         * if NULL the legacy_inner_loop_selector is used instead.
+         * This was blocked off to be the "new" inner loop selector in 1.7,
+         * but this was never implemented. (This is also why the above
+         * selector is called the "legacy" selector.)
          */
-        PyUFunc_InnerLoopSelectionFunc *inner_loop_selector;
+        void *reserved2;
         /*
          * A function which returns a masked inner loop for the ufunc.
          */
         PyUFunc_MaskedInnerLoopSelectionFunc *masked_inner_loop_selector;
+
+        /*
+         * List of flags for each operand when ufunc is called by nditer object.
+         * These flags will be used in addition to the default flags for each
+         * operand set by nditer object.
+         */
+        npy_uint32 *op_flags;
+
+        /*
+         * List of global flags used when ufunc is called by nditer object.
+         * These flags will be used in addition to the default global flags
+         * set by nditer object.
+         */
+        npy_uint32 iter_flags;
+
+        /* New in NPY_API_VERSION 0x0000000D and above */
+
+        /*
+         * for each core_num_dim_ix distinct dimension names,
+         * the possible "frozen" size (-1 if not frozen).
+         */
+        npy_intp *core_dim_sizes;
+
+        /*
+         * for each distinct core dimension, a set of UFUNC_CORE_DIM* flags
+         */
+        npy_uint32 *core_dim_flags;
+
+        /* Identity for reduction, when identity == PyUFunc_IdentityValue */
+        PyObject *identity_value;
+
 } PyUFuncObject;
 
 #include "arrayobject.h"
+/* Generalized ufunc; 0x0001 reserved for possible use as CORE_ENABLED */
+/* the core dimension's size will be determined by the operands. */
+#define UFUNC_CORE_DIM_SIZE_INFERRED 0x0002
+/* the core dimension may be absent */
+#define UFUNC_CORE_DIM_CAN_IGNORE 0x0004
+/* flags inferred during execution */
+#define UFUNC_CORE_DIM_MISSING 0x00040000
 
 #define UFUNC_ERR_IGNORE 0
 #define UFUNC_ERR_WARN   1
@@ -236,22 +261,11 @@ typedef struct _tagPyUFuncObject {
 #define UFUNC_SHIFT_INVALID      9
 
 
-/* platform-dependent code translates floating point
-   status to an integer sum of these values
-*/
-#define UFUNC_FPE_DIVIDEBYZERO  1
-#define UFUNC_FPE_OVERFLOW      2
-#define UFUNC_FPE_UNDERFLOW     4
-#define UFUNC_FPE_INVALID       8
-
-/* Error mode that avoids look-up (no checking) */
-#define UFUNC_ERR_DEFAULT       0
-
 #define UFUNC_OBJ_ISOBJECT      1
 #define UFUNC_OBJ_NEEDS_API     2
 
    /* Default user error mode */
-#define UFUNC_ERR_DEFAULT2                               \
+#define UFUNC_ERR_DEFAULT                               \
         (UFUNC_ERR_WARN << UFUNC_SHIFT_DIVIDEBYZERO) +  \
         (UFUNC_ERR_WARN << UFUNC_SHIFT_OVERFLOW) +      \
         (UFUNC_ERR_WARN << UFUNC_SHIFT_INVALID)
@@ -264,16 +278,22 @@ typedef struct _tagPyUFuncObject {
 #define NPY_LOOP_END_THREADS
 #endif
 
+/*
+ * UFunc has unit of 0, and the order of operations can be reordered
+ * This case allows reduction with multiple axes at once.
+ */
+#define PyUFunc_Zero 0
 /*
  * UFunc has unit of 1, and the order of operations can be reordered
  * This case allows reduction with multiple axes at once.
  */
 #define PyUFunc_One 1
 /*
- * UFunc has unit of 0, and the order of operations can be reordered
- * This case allows reduction with multiple axes at once.
+ * UFunc has unit of -1, and the order of operations can be reordered
+ * This case allows reduction with multiple axes at once. Intended for
+ * bitwise_and reduction.
  */
-#define PyUFunc_Zero 0
+#define PyUFunc_MinusOne 2
 /*
  * UFunc has no unit, and the order of operations cannot be reordered.
  * This case does not allow reduction with multiple axes at once.
@@ -284,6 +304,12 @@ typedef struct _tagPyUFuncObject {
  * This case allows reduction with multiple axes at once.
  */
 #define PyUFunc_ReorderableNone -2
+/*
+ * UFunc unit is an identity_value, and the order of operations can be reordered
+ * This case allows reduction with multiple axes at once.
+ */
+#define PyUFunc_IdentityValue -3
+
 
 #define UFUNC_REDUCE 0
 #define UFUNC_ACCUMULATE 1
@@ -305,6 +331,8 @@ typedef struct _loop1d_info {
         void *data;
         int *arg_types;
         struct _loop1d_info *next;
+        int nargs;
+        PyArray_Descr **arg_dtypes;
 } PyUFunc_Loop1d;
 
 
@@ -312,132 +340,27 @@ typedef struct _loop1d_info {
 
 #define UFUNC_PYVALS_NAME "UFUNC_PYVALS"
 
-#define UFUNC_CHECK_ERROR(arg) \
-        do {if ((((arg)->obj & UFUNC_OBJ_NEEDS_API) && PyErr_Occurred()) || \
-            ((arg)->errormask && \
-             PyUFunc_checkfperr((arg)->errormask, \
-                                (arg)->errobj, \
-                                &(arg)->first))) \
-                goto fail;} while (0)
-
-/* This code checks the IEEE status flags in a platform-dependent way */
-/* Adapted from Numarray  */
-
-#if (defined(__unix__) || defined(unix)) && !defined(USG)
-#include <sys/param.h>
-#endif
-
-/*  OSF/Alpha (Tru64)  ---------------------------------------------*/
-#if defined(__osf__) && defined(__alpha)
-
-#include <machine/fpu.h>
-
-#define UFUNC_CHECK_STATUS(ret) { \
-        unsigned long fpstatus; \
-         \
-        fpstatus = ieee_get_fp_control(); \
-        /* clear status bits as well as disable exception mode if on */ \
-        ieee_set_fp_control( 0 ); \
-        ret = ((IEEE_STATUS_DZE & fpstatus) ? UFUNC_FPE_DIVIDEBYZERO : 0) \
-                | ((IEEE_STATUS_OVF & fpstatus) ? UFUNC_FPE_OVERFLOW : 0) \
-                | ((IEEE_STATUS_UNF & fpstatus) ? UFUNC_FPE_UNDERFLOW : 0) \
-                | ((IEEE_STATUS_INV & fpstatus) ? UFUNC_FPE_INVALID : 0); \
-        }
-
-/* MS Windows -----------------------------------------------------*/
-#elif defined(_MSC_VER)
-
-#include <float.h>
-
-  /* Clear the floating point exception default of Borland C++ */
-#if defined(__BORLANDC__)
-#define UFUNC_NOFPE _control87(MCW_EM, MCW_EM);
-#endif
-
-#define UFUNC_CHECK_STATUS(ret) { \
-        int fpstatus = (int) _clearfp(); \
-         \
-        ret = ((SW_ZERODIVIDE & fpstatus) ? UFUNC_FPE_DIVIDEBYZERO : 0) \
-                | ((SW_OVERFLOW & fpstatus) ? UFUNC_FPE_OVERFLOW : 0) \
-                | ((SW_UNDERFLOW & fpstatus) ? UFUNC_FPE_UNDERFLOW : 0) \
-                | ((SW_INVALID & fpstatus) ? UFUNC_FPE_INVALID : 0); \
-        }
-
-/* Solaris --------------------------------------------------------*/
-/* --------ignoring SunOS ieee_flags approach, someone else can
-**         deal with that! */
-#elif defined(sun) || defined(__BSD__) || defined(__OpenBSD__) || \
-      (defined(__FreeBSD__) && (__FreeBSD_version < 502114)) || \
-      defined(__NetBSD__)
-#include <ieeefp.h>
-
-#define UFUNC_CHECK_STATUS(ret) { \
-        int fpstatus; \
-         \
-        fpstatus = (int) fpgetsticky(); \
-        ret = ((FP_X_DZ  & fpstatus) ? UFUNC_FPE_DIVIDEBYZERO : 0) \
-                | ((FP_X_OFL & fpstatus) ? UFUNC_FPE_OVERFLOW : 0) \
-                | ((FP_X_UFL & fpstatus) ? UFUNC_FPE_UNDERFLOW : 0) \
-                | ((FP_X_INV & fpstatus) ? UFUNC_FPE_INVALID : 0); \
-        (void) fpsetsticky(0); \
-        }
-
-#elif defined(__GLIBC__) || defined(__APPLE__) || \
-      defined(__CYGWIN__) || defined(__MINGW32__) || \
-      (defined(__FreeBSD__) && (__FreeBSD_version >= 502114))
-
-#if defined(__GLIBC__) || defined(__APPLE__) || \
-    defined(__MINGW32__) || defined(__FreeBSD__)
-#include <fenv.h>
-#endif
-
-#define UFUNC_CHECK_STATUS(ret) { \
-        int fpstatus = (int) fetestexcept(FE_DIVBYZERO | FE_OVERFLOW | \
-                                          FE_UNDERFLOW | FE_INVALID); \
-        ret = ((FE_DIVBYZERO  & fpstatus) ? UFUNC_FPE_DIVIDEBYZERO : 0) \
-                | ((FE_OVERFLOW   & fpstatus) ? UFUNC_FPE_OVERFLOW : 0) \
-                | ((FE_UNDERFLOW  & fpstatus) ? UFUNC_FPE_UNDERFLOW : 0) \
-                | ((FE_INVALID    & fpstatus) ? UFUNC_FPE_INVALID : 0); \
-        (void) feclearexcept(FE_DIVBYZERO | FE_OVERFLOW | \
-                             FE_UNDERFLOW | FE_INVALID); \
-}
-
-#elif defined(_AIX)
-
-#include <float.h>
-#include <fpxcp.h>
-
-#define UFUNC_CHECK_STATUS(ret) { \
-        fpflag_t fpstatus; \
- \
-        fpstatus = fp_read_flag(); \
-        ret = ((FP_DIV_BY_ZERO & fpstatus) ? UFUNC_FPE_DIVIDEBYZERO : 0) \
-                | ((FP_OVERFLOW & fpstatus) ? UFUNC_FPE_OVERFLOW : 0)   \
-                | ((FP_UNDERFLOW & fpstatus) ? UFUNC_FPE_UNDERFLOW : 0) \
-                | ((FP_INVALID & fpstatus) ? UFUNC_FPE_INVALID : 0); \
-        fp_swap_flag(0); \
-}
-
-#else
-
-#define NO_FLOATING_POINT_SUPPORT
-#define UFUNC_CHECK_STATUS(ret) { \
-    ret = 0; \
-  }
-
-#endif
-
 /*
  * THESE MACROS ARE DEPRECATED.
  * Use npy_set_floatstatus_* in the npymath library.
  */
+#define UFUNC_FPE_DIVIDEBYZERO  NPY_FPE_DIVIDEBYZERO
+#define UFUNC_FPE_OVERFLOW      NPY_FPE_OVERFLOW
+#define UFUNC_FPE_UNDERFLOW     NPY_FPE_UNDERFLOW
+#define UFUNC_FPE_INVALID       NPY_FPE_INVALID
+
 #define generate_divbyzero_error() npy_set_floatstatus_divbyzero()
 #define generate_overflow_error() npy_set_floatstatus_overflow()
 
   /* Make sure it gets defined if it isn't already */
 #ifndef UFUNC_NOFPE
+/* Clear the floating point exception default of Borland C++ */
+#if defined(__BORLANDC__)
+#define UFUNC_NOFPE _control87(MCW_EM, MCW_EM);
+#else
 #define UFUNC_NOFPE
 #endif
+#endif
 
 
 #ifdef __cplusplus
diff --git a/include/numpy/utils.h b/include/numpy/utils.h
index cc968a354..32218b8c7 100644
--- a/include/numpy/utils.h
+++ b/include/numpy/utils.h
@@ -6,6 +6,8 @@
                 #define __COMP_NPY_UNUSED __attribute__ ((__unused__))
         # elif defined(__ICC)
                 #define __COMP_NPY_UNUSED __attribute__ ((__unused__))
+        # elif defined(__clang__)
+                #define __COMP_NPY_UNUSED __attribute__ ((unused))
         #else
                 #define __COMP_NPY_UNUSED
         #endif
